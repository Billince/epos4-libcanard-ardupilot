/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "usb_host.h"
#include "../libcanard/canard.h"
#include <stdlib.h>
#include <string.h>
#include "epos4.h"
#include <stdio.h>  // Add stdio.h for printf
#include <stdarg.h> // Add stdarg.h for variable arguments
#include "stm32f4xx_hal.h"
#include "stm32f4xx_hal_can.h"
#include "stm32f4xx_hal_gpio.h"
#include "stm32f4xx_hal_rcc.h"
#include "stm32f4xx_hal_cortex.h"
// Add IWDG suppor
/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

// UAVCAN message type definitions
#define UAVCAN_PROTOCOL_NODE_STATUS_MESSAGE_ID    341
#define UAVCAN_PROTOCOL_GETNODEINFO_ID            1
#define UAVCAN_PROTOCOL_PARAM_GETSET_ID           11
#define UAVCAN_PROTOCOL_ACCESS_COMMAND_ID         11

// UAVCAN Equipment Actuator Status message definitions
#define UAVCAN_EQUIPMENT_ACTUATOR_STATUS_DATA_TYPE_ID            1011
#define UAVCAN_EQUIPMENT_ACTUATOR_STATUS_DATA_TYPE_SIGNATURE     0x5E9BBA44CBEADED3ULL
#define UAVCAN_EQUIPMENT_ACTUATOR_STATUS_MAX_SIZE                48  // Bytes

// UAVCAN Equipment Actuator ArrayCommand message definitions
#define UAVCAN_EQUIPMENT_ACTUATOR_ARRAYCOMMAND_ID 1010
#define UAVCAN_EQUIPMENT_ACTUATOR_ARRAYCOMMAND_SIGNATURE 0xd8a7486238ec3af3ULL

// ArduPilot specific signature for debugging (message type 20007)
#define ARDUPILOT_GNSS_STATUS_ID 20007
#define ARDUPILOT_GNSS_STATUS_SIGNATURE 0xFEDCBA0987654321ULL  // Placeholder signature

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
// DroneCAN/UAVCAN definitions
#define CANARD_CAN_EXT_ID_MASK         0x1FFFFFFFU
#define NODE_ID                        9
#define UAVCAN_NODE_STATUS_MESSAGE_SIZE 7  // Standard size (not 90)
#define UAVCAN_NODE_STATUS_DATA_TYPE_ID 341
#define UAVCAN_NODE_STATUS_DATA_TYPE_SIGNATURE 0x0f0868d0c1a7c6f1ULL

#define UAVCAN_PROTOCOL_GETNODEINFO_SIGNATURE 0xEE468A8121C46A9EULL
#define UAVCAN_PROTOCOL_GETNODEINFO_REQUEST_SIGNATURE 0xEE468A8121C46A9EULL

// GetNodeInfo service definitions
#define UAVCAN_GET_NODE_INFO_DATA_TYPE_ID 1
#define UAVCAN_GET_NODE_INFO_DATA_TYPE_SIGNATURE 0xee468a8121c46a9e
#define UAVCAN_GET_NODE_INFO_RESPONSE_MAX_SIZE ((3015 + 7) / 8)

// Add the correct dynamic node ID allocation signature
#define UAVCAN_PROTOCOL_DYNAMIC_NODE_ID_ALLOCATION_SIGNATURE 0x0b2a812620a11d40ULL

// Add the correct actuator array command signature
#define UAVCAN_EQUIPMENT_ACTUATOR_ARRAYCOMMAND_SIGNATURE 0xd8a7486238ec3af3ULL

#define UNIQUE_ID_LENGTH_BYTES                                      16

// Parameter protocol definitions
#define UAVCAN_PARAM_STRING_ID 341 // Changed from 11 to avoid conflict with node ID 
#define UAVCAN_PARAM_STRING_SIGNATURE 0xe02f25d6e0c98ae0ULL
#define UAVCAN_PARAM_GETSET_ID 11
#define UAVCAN_PARAM_GETSET_SIGNATURE 0xa7b622f939d1a4d5    

// Read/Write register definitions (used by ArduPilot for node naming)
#define UAVCAN_PROTOCOL_PARAM_VALUE_SIZE 60
#define UAVCAN_PROTOCOL_REGISTER_ACCESS_ID 85
#define UAVCAN_PROTOCOL_REGISTER_ACCESS_SIGNATURE 0xb7d72a90bc4bc330ULL

// UAVCAN Raw Command message (for motor control)
#define UAVCAN_RAW_COMMAND_ID 30
#define UAVCAN_RAW_COMMAND_SIGNATURE 0x59276cb31ad99c85ULL

// EPOS4 node ID for CANopen control
#define EPOS4_NODE_ID                  1   // Default node ID for EPOS4
#define EPOS4_RESOLUTION               4096 // Encoder resolution (counts per rev)
#define EPOS4_MAX_VELOCITY             20000 // Default velocity for movements
#define EPOS4_MAX_ACCELERATION         50000 // Default acceleration for movements

// SDO command definitions for EPOS4
#define EPOS4_SDO_WRITE                0x600 // SDO write request base ID
#define EPOS4_SDO_READ_REPLY           0x580 // SDO read reply base ID

// EPOS4 Object Dictionary indexes
#define EPOS4_CONTROLWORD_INDEX        0x6040
#define EPOS4_STATUSWORD_INDEX         0x6041
#define EPOS4_MODE_OF_OPERATION_INDEX  0x6060
#define EPOS4_TARGET_VELOCITY_INDEX    0x60FF
#define EPOS4_ACTUAL_VELOCITY_INDEX    0x606C
#define EPOS4_TARGET_POSITION_INDEX    0x607A
#define EPOS4_ACTUAL_POSITION_INDEX    0x6064
#define EPOS4_ACTUAL_POSITION_SUBINDEX 0x00

// Position limits for tilt control
#define TILT_MIN_POSITION              -10000  // Minimum tilt position
#define TILT_MAX_POSITION              10000   // Maximum tilt position
#define TILT_CENTER_POSITION           0       // Center position

#define UAVCAN_NODE_HEALTH_OK          0
#define UAVCAN_NODE_HEALTH_WARNING     1
#define UAVCAN_NODE_HEALTH_ERROR       2
#define UAVCAN_NODE_HEALTH_CRITICAL    3

#define UAVCAN_NODE_MODE_OPERATIONAL   0
#define UAVCAN_NODE_MODE_INITIALIZATION 1
#define UAVCAN_NODE_MODE_MAINTENANCE   2
#define UAVCAN_NODE_MODE_SOFTWARE_UPDATE 3
#define UAVCAN_NODE_MODE_OFFLINE       7

// Ensure CanardTransferTypeMessage is defined in case the libcanard version doesn't match
#ifndef CanardTransferTypeMessage
#define CanardTransferTypeMessage 2
#endif

// Node name and version info
#define APP_VERSION_MAJOR 1
#define APP_VERSION_MINOR 0
#define APP_NODE_NAME "epos4.motorctl"  // Better name to match parameter format
#define APP_NODE_NAME_MAX_LENGTH 80 // Maximum length of node name string
#define GIT_HASH  0xBADC0FFE

// Remove conflicting position macros
// #define MIN_POSITION -10000  // Minimum tilt position
// #define MAX_POSITION 10000   // Maximum tilt position
// #define CENTER_POSITION 0    // Center position
#define COMMAND_DEADBAND 100 // Deadband for stability

// Remove duplicate EPOS4 configuration - already defined above
// #define EPOS4_NODE_ID          1
// #define EPOS4_MAX_ACCELERATION 5000
// #define EPOS4_MAX_VELOCITY     1000
// #define EPOS4_RESOLUTION       1024

// Parameter system definitions
#define MAX_PARAMETERS              100
#define PARAM_NAME_MAX_LENGTH       16
#define EPOS4_POSITION_LIMIT        100000

// Define param_t type
typedef struct parameter param_t;

// Parameter type enumeration
enum param_type {
    PARAM_TYPE_EMPTY = 0,
    PARAM_TYPE_INTEGER = 1,
    PARAM_TYPE_BOOLEAN = 2,
    PARAM_TYPE_REAL = 3, 
    PARAM_TYPE_STRING = 4
};

// Parameter structure definition
struct parameter {
    char name[PARAM_NAME_MAX_LENGTH];
    enum param_type type;
    union {
        int32_t i;
        float f;
        bool b;
        char str[PARAM_NAME_MAX_LENGTH];
    } value;
    int32_t val;
    int64_t defval;  // Add default value
    int64_t max;     // Add max value
    int64_t min;     // Add min value
};

// Parameter storage
static struct parameter parameters[MAX_PARAMETERS] = {
    {"epos4.node_name", PARAM_TYPE_STRING, .value.str = "motorctl", .val = 0, .min = 0, .max = 0, .defval = 0},
    {"epos4.can_id", PARAM_TYPE_INTEGER, .value.i = NODE_ID, .val = NODE_ID, .min = 1, .max = 127, .defval = NODE_ID},
    {"epos4.drv_id", PARAM_TYPE_INTEGER, .value.i = EPOS4_NODE_ID, .val = EPOS4_NODE_ID, .min = 1, .max = 127, .defval = EPOS4_NODE_ID},
    {"epos4.min_pos", PARAM_TYPE_REAL, .value.f = -1.0f, .val = -1, .min = -1, .max = 0, .defval = -1},
    {"epos4.max_pos", PARAM_TYPE_REAL, .value.f = 1.0f, .val = 1, .min = 0, .max = 1, .defval = 1},
    {"epos4.center", PARAM_TYPE_REAL, .value.f = 0.0f, .val = 0, .min = -1, .max = 1, .defval = 0},
    {"epos4.vel_max", PARAM_TYPE_INTEGER, .value.i = EPOS4_MAX_VELOCITY, .val = EPOS4_MAX_VELOCITY, .min = 0, .max = 10000, .defval = EPOS4_MAX_VELOCITY},
    {"epos4.accel", PARAM_TYPE_INTEGER, .value.i = EPOS4_MAX_ACCELERATION, .val = EPOS4_MAX_ACCELERATION, .min = 0, .max = 50000, .defval = EPOS4_MAX_ACCELERATION},
    {"epos4.op_mode", PARAM_TYPE_INTEGER, .value.i = 1, .val = 1, .min = 0, .max = 10, .defval = 1},  // 1=Position, 3=Velocity
    {"epos4.res", PARAM_TYPE_INTEGER, .value.i = EPOS4_RESOLUTION, .val = EPOS4_RESOLUTION, .min = 1, .max = 10000, .defval = EPOS4_RESOLUTION},
    {"epos4.pos", PARAM_TYPE_REAL, .value.f = 0.0f, .val = 0, .min = -1, .max = 1, .defval = 0}
};

// Parameter handling function declarations
static inline param_t * getParamByIndex(uint16_t index);
static inline param_t * getParamByName(const char * name);

// Make position variables global
static int32_t maxPosition = 0;          // Maximum position value (0)
static int32_t midPosition = -144000;    // Middle position (-144000)
static int32_t minPosition = -288000;    // Minimum position (-288000)
static int32_t targetPosition = -144000; // Start at middle position
static uint8_t positionIndex = 1;        // Start at middle position (1=mid) btw just for your info im using a screwdrive motor that turns so the brass makes my drone tilt


// External variables
extern int32_t current_position;

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
CAN_HandleTypeDef hcan1;

I2S_HandleTypeDef hi2s3;

SPI_HandleTypeDef hspi1;

// Add heartbeat timing variables
static uint32_t last_heartbeat_ms = 0;
static const uint32_t HEARTBEAT_INTERVAL_MS = 500;  // 500ms between heartbeats

// Add current_position variable
int32_t current_position = 0;  // Current position of the EPOS4 motor



/* USER CODE BEGIN PV */
// Memory pool for libcanard
static uint8_t canard_memory_pool[16384];  // Increased to match CAN_D1_UC_POOL
// Canard instance
CanardInstance canard;

// Debug LED states
uint8_t can_tx_led = 0;
uint8_t can_rx_led = 0;

// Transfer ID for UAVCAN messages
static uint8_t transfer_id = 0;

// Message port ID for Real64 array (Yakut test message)
#define MSG_PORT_ID 1620U
static uint8_t my_message_transfer_id = 0;
static uint8_t param_transfer_id = 0;  // Added declaration for parameter transfer ID
uint32_t test_uptimeSec = 0;
// Buffer for heartbeat messages
#define HEARTBEAT_BUFFER_SIZE 16
uint8_t hbeat_ser_buf[HEARTBEAT_BUFFER_SIZE];

// UART related variables
uint8_t uart_rx_ready = 0;
uint8_t uart_rx_buffer[256];

// Add these to the top of the file, after includes but before your declarations
#define UAVCAN_PROTOCOL_PARAM_GETSET_SIGNATURE 0xa7b622f939d1a4d5ULL

// In the Private variables section, add these variables
uint64_t next_1hz_service_at = 0;
uint64_t ts = 0;
uint32_t current_ms = 0;
uint32_t last_epos4_statuscheck_ms = 0;
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_CAN1_Init(void);
static void MX_I2S3_Init(void);
static void MX_SPI1_Init(void);
void MX_USB_HOST_Process(void);

// Add function declarations
void send_get_node_info_request(uint8_t target_node_id);
void send_actuator_status(void);

/* USER CODE BEGIN PFP */
static void* memAllocate(CanardInstance* const ins, const size_t amount);
static void memFree(CanardInstance* const ins, void* const pointer);
void process_canard_TX_queue(void);
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan);
void HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef *hcan);
void send_NodeStatus(void);
static bool shouldAcceptTransfer(const CanardInstance* ins,
                                uint64_t* out_data_type_signature,
                                uint16_t data_type_id,
                                CanardTransferType transfer_type,
                                uint8_t source_node_id);
void onTransferReceived(CanardInstance* ins, CanardRxTransfer* transfer);
void handle_get_node_info(CanardInstance* ins, CanardRxTransfer* transfer);
void handleActuatorArrayCommand(CanardInstance* ins, CanardRxTransfer* transfer);
void initializePositionParameters(void);
uint16_t makeNodeInfoMessage(uint8_t buffer[UAVCAN_GET_NODE_INFO_RESPONSE_MAX_SIZE]);
void makeNodeStatusMessage(uint8_t buffer[UAVCAN_NODE_STATUS_MESSAGE_SIZE]);
void Error_Handler(void);


// EPOS4 functions via CANopen communication
void CANopen_NMT_Command(CAN_HandleTypeDef* hcan, uint8_t command, uint8_t node_id);
void EPOS4_SetOperationMode(CAN_HandleTypeDef* hcan, uint8_t node_id, uint8_t mode);
void EPOS4_SetProfileVelocity(CAN_HandleTypeDef* hcan, uint8_t node_id, uint32_t velocity);
void EPOS4_SetProfileAcceleration(CAN_HandleTypeDef* hcan, uint8_t node_id, uint32_t acceleration);
void EPOS4_SetProfileDeceleration(CAN_HandleTypeDef* hcan, uint8_t node_id, uint32_t deceleration);

// Functions for epos4 via libcanard
void epos4_send_sdo_write(uint16_t index, uint8_t subindex, uint32_t data, uint8_t data_length);
void epos4_send_sdo_read(uint16_t index, uint8_t subindex);
void epos4_read_position(uint16_t index, uint8_t subindex);
void epos4_set_operation_mode(uint8_t mode);
void epos4_set_target_velocity(int32_t target_velocity);
void epos4_set_target_position(int32_t target_position);
void epos4_enable_motor(void);
void epos4_disable_motor(void);
void epos4_send_pdo(uint16_t cob_id, uint8_t* data, uint8_t length);
void handle_ardupilot_command(int16_t command_value);

// EPOS4 CANopen interface functions
bool EPOS4_SetTargetPosition_Legacy(CAN_HandleTypeDef* hcan, uint8_t node_id, int32_t position);
void EPOS4_SetControlWord(CAN_HandleTypeDef* hcan, uint8_t node_id, uint16_t control_word);
bool EPOS4_Init_Legacy(CAN_HandleTypeDef* hcan, uint8_t node_id);

// Add these function prototypes to the proper section (in USER CODE BEGIN PFP)
void processTxRxOnce(CanardInstance *ins, uint32_t timeout_ms);
uint64_t micros64(void);
void process1HzTasks(uint64_t timestamp_usec);
void handle_param_getset(CanardInstance* ins, CanardRxTransfer* transfer);
void save_settings(void);
void ITM_Init(void);
void rawcmdHandleCanard(CanardRxTransfer* transfer);
float translateEPOS4Position(int32_t position);
float getEPOS4NormalizedPosition(void);
int32_t getNormalizedToEPOS4Position(float normalized_position);
// Add this declaration with the other function prototypes
void broadcast_all_parameters(void);
// Add our new function prototype with the other function prototypes in the appropriate section
void force_motor_movement(int32_t position);
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* Initialize ITM for debug output */
  ITM_Init();

  /* USER CODE BEGIN Init */
  
 /* Check reset flags to determine reset cause */
   if ((RCC->CSR & RCC_CSR_IWDGRSTF) != 0) {
     printf("System reset caused by Independent Watchdog (IWDG)\r\n");
     RCC->CSR |= RCC_CSR_RMVF; // Clear all reset flags
   }
   
   /* Configure IWDG with direct register access */
   // Start by writing the key to unlock IWDG registers
   IWDG->KR = 0x5555; // Enable write access to IWDG_PR and IWDG_RLR
   
   // Set prescaler to maximum value (256) using direct register access
   IWDG->PR = 0x07; // Max prescaler (divide by 256)
   
   // Set reload value to maximum (0xFFF = 4095) using direct register access 
   IWDG->RLR = 0xFFF; // Max reload value
   
   // Reload the watchdog counter to apply settings
   IWDG->KR = 0xAAAA;
   
   // Start the watchdog
   IWDG->KR = 0xCCCC;
   
   printf("IWDG configured with maximum timeout using direct register access\r\n");
  
  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_CAN1_Init();
  MX_I2S3_Init();
  MX_SPI1_Init();
  MX_USB_HOST_Init();
  
  /* USER CODE BEGIN 2 */
  // Initialize LEDs
  HAL_GPIO_WritePin(GPIOD, LD4_Pin, GPIO_PIN_RESET); // Green LED off
  HAL_GPIO_WritePin(GPIOD, LD3_Pin, GPIO_PIN_RESET); // Red LED off
  HAL_GPIO_WritePin(GPIOD, LD5_Pin, GPIO_PIN_RESET); // Orange LED off
  HAL_GPIO_WritePin(GPIOD, LD6_Pin, GPIO_PIN_RESET); // Blue LED off
  
  printf("-------------------------------------\r\n");
  printf("EPOS4 UAVCAN Node - Starting up\r\n");
  printf("STM32F4Discovery with CAN interface\r\n");
  printf("Node ID: %d\r\n", NODE_ID);
  printf("-------------------------------------\r\n");
  
  // Configure CAN filter to accept ALL messages with no filtering
  CAN_FilterTypeDef canFilter;
  canFilter.FilterBank = 0;
  canFilter.FilterMode = CAN_FILTERMODE_IDMASK;
  canFilter.FilterScale = CAN_FILTERSCALE_32BIT;
  canFilter.FilterIdHigh = 0x0000;
  canFilter.FilterIdLow = 0x0000;  // Accept any ID
  canFilter.FilterMaskIdHigh = 0x0000;  // Don't mask any bits (accept everything)
  canFilter.FilterMaskIdLow = 0x0000;   // Don't mask any bits (accept everything)
  canFilter.FilterFIFOAssignment = CAN_FILTER_FIFO0;
  canFilter.FilterActivation = CAN_FILTER_ENABLE;
  
  if (HAL_CAN_ConfigFilter(&hcan1, &canFilter) != HAL_OK) {
    Error_Handler();
  }
  
  // Enable CAN bus
  if (HAL_CAN_Start(&hcan1) != HAL_OK) {
    Error_Handler();
  }
  
  // Enable CAN interrupts for receive
  if (HAL_CAN_ActivateNotification(&hcan1, CAN_IT_RX_FIFO0_MSG_PENDING) != HAL_OK) {
    Error_Handler();
  }
  
  // Start libcanard
  canardInit(&canard, canard_memory_pool, sizeof(canard_memory_pool), onTransferReceived, shouldAcceptTransfer, NULL);
  canardSetLocalNodeID(&canard, NODE_ID);
  
  // Initialize EPOS4 controller and wait for initialization to complete
  HAL_GPIO_WritePin(GPIOD, LD3_Pin | LD4_Pin | LD5_Pin | LD6_Pin, GPIO_PIN_RESET);
  HAL_Delay(300);
  
  // Initialize EPOS4 controller for position control mode
  
  // Step 1: Reset communications
  CANopen_NMT_Command(&hcan1, 0x82, EPOS4_NODE_ID); // 0x82 = Reset communications
  HAL_Delay(100); // Wait for reset to complete
  
  // Step 2: Start remote node
  CANopen_NMT_Command(&hcan1, 0x01, EPOS4_NODE_ID); // 0x01 = Start remote node
  HAL_Delay(100);
  
  // Step 3: Set operation mode to position mode
  EPOS4_SetOperationMode(&hcan1, EPOS4_NODE_ID, MODE_PROFILE_POSITION);
  HAL_Delay(100);
  
  // Step 4: Set control word to shutdown state (prepare for enable)
  EPOS4_SetControlWord(&hcan1, EPOS4_NODE_ID, 0x0006);
  HAL_Delay(100);
  
  // Step 5: Set control word to switch on state
  EPOS4_SetControlWord(&hcan1, EPOS4_NODE_ID, 0x0007);
  HAL_Delay(100);
  
  // Step 6: Configure motion profile parameters for smooth tilt movement
  // Profile velocity (speed during positioning)
  EPOS4_SetProfileVelocity(&hcan1, EPOS4_NODE_ID, 5000);
  HAL_Delay(50);
  
  // Profile acceleration (ramp-up rate)
  EPOS4_SetProfileAcceleration(&hcan1, EPOS4_NODE_ID, 10000);
  HAL_Delay(50);
  
  // Profile deceleration (ramp-down rate)
  EPOS4_SetProfileDeceleration(&hcan1, EPOS4_NODE_ID, 10000);
  HAL_Delay(50);
  
  // Step 7: Enable operation
  EPOS4_SetControlWord(&hcan1, EPOS4_NODE_ID, 0x000F);
  HAL_Delay(100);
  
  printf("EPOS4 initialization complete\r\n");
  
  // Send node info to announce our presence
  HAL_GPIO_WritePin(GPIOD, LD5_Pin, GPIO_PIN_SET); // Blue LED on when node is active
  HAL_Delay(50); // Short delay for stability
  
  // Broadcast all parameters so they appear quickly in the inspector
  printf("Broadcasting all parameters for quick discovery...\r\n");
  broadcast_all_parameters();
  
  printf("UAVCAN Node ready\r\n");
  
  // Try moving motor using both approaches
  printf("Moving motor to maximum position at startup...\r\n");
  HAL_Delay(500); // Give some time before starting movement
  
  // First try with normal function
  int32_t startup_position = 50000; // Use a large positive value
  printf("Sending absolute position command: %ld\r\n", (long)startup_position);
  epos4_set_target_position(startup_position);
  
  // Wait for motion to complete
  HAL_Delay(1000); // Wait a second for movement
  
  // Now try with direct function
  printf("Trying with direct force motor command\r\n");
  force_motor_movement(100000); // Even larger value
  
  // Wait for motion to complete
  HAL_Delay(2000); // Wait longer for this movement
  
  // Blink LED to indicate motions completed
  for (int i = 0; i < 3; i++) {
    HAL_GPIO_TogglePin(GPIOD, LD4_Pin); // Toggle green LED
    HAL_Delay(100);
  }
  
  printf("Startup movement completed - beginning main loop\r\n");
  /* USER CODE END 2 */

  // *** Add after the main loop initialization ***
  uint64_t last_getnodeinfo_self_request_time_ms = 0;
  
  // Initialize EPOS4 motor controller after CAN initialization
  if (EPOS4_Init_Legacy(&hcan1, EPOS4_NODE_ID)) {
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_SET); // Green LED on success
  } else {
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_14, GPIO_PIN_SET); // Red LED on failure
  }
  
  // Initialize position parameters with defaults
  initializePositionParameters();
  
  // Broadcast parameters to improve detection speed
  printf("Broadcasting all parameters for quick discovery...\r\n");
  broadcast_all_parameters();
  
  // Move the motor to maximum position at startup
  printf("Moving motor to maximum position at startup...\r\n");
  HAL_Delay(500); // Give some time before starting movement
  
  // Set control word to enable operation and prepare for motion
  EPOS4_SetControlWord(&hcan1, EPOS4_NODE_ID, 0x000F);
  HAL_Delay(100);
  
  // Move to max position
  // Use the maxPosition global variable to know where to go
  int32_t startup_position = maxPosition; // Use maximum position
  if (startup_position == 0) { // If max position hasn't been properly set, use a default
    startup_position = 10000;
  }
  
  // Send the position command
  printf("Sending absolute position command: %ld\r\n", (long)startup_position);
  epos4_set_target_position(startup_position);
  
  // Wait for motion to complete
  HAL_Delay(1000); // Wait a second for movement
  
  // Blink LED to indicate motion completed
  for (int i = 0; i < 3; i++) {
    HAL_GPIO_TogglePin(GPIOD, LD4_Pin); // Toggle green LED
    HAL_Delay(100);
  }
  
  printf("UAVCAN Node ready\r\n");
  /* USER CODE END 3 */

  /* Infinite loop */
  while (1)
  {
    /* USER CODE END WHILE */
    MX_USB_HOST_Process();
    
    /* USER CODE BEGIN 3 */

    // Refresh the watchdog timer to prevent system reset
    IWDG->KR = 0xAAAA;
    
    // Get the current time
    uint64_t current_time_ms = HAL_GetTick();
    uint64_t current_time_us = micros64();
    
    // Simple loop counter for debugging how many cycles we've completed
    static uint32_t loop_counter = 0;
    if (loop_counter++ % 1000 == 0) {
        printf("Main loop cycle %lu, uptime: %lu sec\r\n", 
              (unsigned long)loop_counter, (unsigned long)(current_time_ms / 1000));
    }
    
    // Process CAN messages and send heartbeat every second - with timeout
    process1HzTasks(current_time_us);
    
    // Check for any received CAN frames (non-blocking, 10ms timeout)
    processTxRxOnce(&canard, 10);
    
    // Refresh watchdog again
    IWDG->KR = 0xAAAA;
    
    // Special debug code - send a GetNodeInfo request to our own node periodically
    // This can help determine if the broadcast GetNodeInfo requests are working
    if (current_time_ms - last_getnodeinfo_self_request_time_ms > 5000) {  // every 5 seconds
        printf("DEBUG: Sending GetNodeInfo request to our own node (ID=%d)...\r\n", NODE_ID);
        send_get_node_info_request(NODE_ID);
        last_getnodeinfo_self_request_time_ms = current_time_ms;
    }
    
    // Periodically broadcast all parameters to improve discovery and accessibility
    static uint64_t last_parameter_broadcast_ms = 0;
    if (current_time_ms - last_parameter_broadcast_ms > 10000) {  // every 10 seconds
        printf("Periodically broadcasting all parameters...\r\n");
        broadcast_all_parameters();
        last_parameter_broadcast_ms = current_time_ms;
    }
    
    // Cleanup any stale transfers
    canardCleanupStaleTransfers(&canard, current_time_us);
    
    // Small delay to prevent CPU hogging
    HAL_Delay(1);
  }
  /* USER CODE END 3 */

  // After existing code for initialization in main() function, add:

  // Initialize EPOS4 motor controller after CAN initialization
  if (EPOS4_Init_Legacy(&hcan1, EPOS4_NODE_ID)) {
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_SET); // Green LED on success
  } else {
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_14, GPIO_PIN_SET); // Red LED on failure
  }
  
  // Initialize position parameters with defaults
  initializePositionParameters();
  
  // Broadcast parameters to improve detection speed
  printf("Broadcasting all parameters for quick discovery...\r\n");
  broadcast_all_parameters();
  
  // Try moving motor using both approaches
  printf("Moving motor to maximum position at startup...\r\n");
  HAL_Delay(500); // Give some time before starting movement
  
  // First try with normal function
  int32_t startup_position = 50000; // Use a large positive value
  printf("Sending absolute position command: %ld\r\n", (long)startup_position);
  epos4_set_target_position(startup_position);
  
  // Wait for motion to complete
  HAL_Delay(1000); // Wait a second for movement
  
  // Now try with direct function
  printf("Trying with direct force motor command\r\n");
  force_motor_movement(100000); // Even larger value
  
  // Wait for motion to complete
  HAL_Delay(2000); // Wait longer for this movement
  
  // Blink LED to indicate motions completed
  for (int i = 0; i < 3; i++) {
    HAL_GPIO_TogglePin(GPIOD, LD4_Pin); // Toggle green LED
    HAL_Delay(100);
  }
  
  printf("UAVCAN Node ready\r\n");
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 7;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief CAN1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_CAN1_Init(void)
{

  /* USER CODE BEGIN CAN1_Init 0 */

  /* USER CODE END CAN1_Init 0 */

  /* USER CODE BEGIN CAN1_Init 1 */

  /* USER CODE END CAN1_Init 1 */
  hcan1.Instance = CAN1;
  
  // Configure for 1Mbps with 168MHz clock (APB1 = 42MHz)
  hcan1.Init.Prescaler = 3;
  hcan1.Init.Mode = CAN_MODE_NORMAL;
  hcan1.Init.SyncJumpWidth = CAN_SJW_1TQ;
  hcan1.Init.TimeSeg1 = CAN_BS1_11TQ;  // Changed from 12TQ to 11TQ
  hcan1.Init.TimeSeg2 = CAN_BS2_2TQ;   // Changed from 1TQ to 2TQ
  
  hcan1.Init.TimeTriggeredMode = DISABLE;
  hcan1.Init.AutoBusOff = ENABLE;      // Enable auto recovery from bus-off state
  hcan1.Init.AutoWakeUp = DISABLE;
  hcan1.Init.AutoRetransmission = ENABLE;
  hcan1.Init.ReceiveFifoLocked = DISABLE;
  hcan1.Init.TransmitFifoPriority = DISABLE;
  
  if (HAL_CAN_Init(&hcan1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN CAN1_Init 2 */

  /* USER CODE END CAN1_Init 2 */

  // Initialize EPOS4 motor controller after CAN initialization
  if (EPOS4_Init_Legacy(&hcan1, EPOS4_NODE_ID)) {
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_SET); // Green LED on success
  } else {
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_14, GPIO_PIN_SET); // Red LED on failure
  }
}

/**
  * @brief I2S3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2S3_Init(void)
{

  /* USER CODE BEGIN I2S3_Init 0 */

  /* USER CODE END I2S3_Init 0 */

  /* USER CODE BEGIN I2S3_Init 1 */

  /* USER CODE END I2S3_Init 1 */
  hi2s3.Instance = SPI3;
  hi2s3.Init.Mode = I2S_MODE_MASTER_TX;
  hi2s3.Init.Standard = I2S_STANDARD_PHILIPS;
  hi2s3.Init.DataFormat = I2S_DATAFORMAT_16B;
  hi2s3.Init.MCLKOutput = I2S_MCLKOUTPUT_ENABLE;
  hi2s3.Init.AudioFreq = I2S_AUDIOFREQ_96K;
  hi2s3.Init.CPOL = I2S_CPOL_LOW;
  hi2s3.Init.ClockSource = I2S_CLOCK_PLL;
  hi2s3.Init.FullDuplexMode = I2S_FULLDUPLEXMODE_DISABLE;
  if (HAL_I2S_Init(&hi2s3) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2S3_Init 2 */

  /* USER CODE END I2S3_Init 2 */

}

/**
  * @brief SPI1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI1_Init(void)
{

  /* USER CODE BEGIN SPI1_Init 0 */

  /* USER CODE END SPI1_Init 0 */

  /* USER CODE BEGIN SPI1_Init 1 */

  /* USER CODE END SPI1_Init 1 */
  /* SPI1 parameter configuration*/
  hspi1.Instance = SPI1;
  hspi1.Init.Mode = SPI_MODE_MASTER;
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi1.Init.NSS = SPI_NSS_SOFT;
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi1.Init.CRCPolynomial = 10;
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN SPI1_Init 2 */

  /* USER CODE END SPI1_Init 2 */

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStruct = {0};
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

    /* GPIO Ports Clock Enable */
    __HAL_RCC_GPIOE_CLK_ENABLE();
    __HAL_RCC_GPIOC_CLK_ENABLE();
    __HAL_RCC_GPIOH_CLK_ENABLE();
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_GPIOB_CLK_ENABLE();
    __HAL_RCC_GPIOD_CLK_ENABLE();

    /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(CS_I2C_SPI_GPIO_Port, CS_I2C_SPI_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(OTG_FS_PowerSwitchOn_GPIO_Port, OTG_FS_PowerSwitchOn_Pin, GPIO_PIN_SET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin
                          |Audio_RST_Pin, GPIO_PIN_RESET);

    /*Configure GPIO pin : CS_I2C_SPI_Pin */
    GPIO_InitStruct.Pin = CS_I2C_SPI_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(CS_I2C_SPI_GPIO_Port, &GPIO_InitStruct);

    /*Configure GPIO pin : OTG_FS_PowerSwitchOn_Pin */
    GPIO_InitStruct.Pin = OTG_FS_PowerSwitchOn_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(OTG_FS_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);

    /*Configure GPIO pin : PDM_OUT_Pin */
    GPIO_InitStruct.Pin = PDM_OUT_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
    HAL_GPIO_Init(PDM_OUT_GPIO_Port, &GPIO_InitStruct);

    /*Configure GPIO pin : B1_Pin */
    GPIO_InitStruct.Pin = B1_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);

    /*Configure GPIO pin : BOOT1_Pin */
    GPIO_InitStruct.Pin = BOOT1_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(BOOT1_GPIO_Port, &GPIO_InitStruct);

    /*Configure GPIO pin : CLK_IN_Pin */
    GPIO_InitStruct.Pin = CLK_IN_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
    HAL_GPIO_Init(CLK_IN_GPIO_Port, &GPIO_InitStruct);

    /*Configure GPIO pins : LD4_Pin LD3_Pin LD5_Pin LD6_Pin
                             Audio_RST_Pin */
    GPIO_InitStruct.Pin = LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin
                            |Audio_RST_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);

    /*Configure GPIO pin : OTG_FS_OverCurrent_Pin */
    GPIO_InitStruct.Pin = OTG_FS_OverCurrent_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(OTG_FS_OverCurrent_GPIO_Port, &GPIO_InitStruct);

    /*Configure GPIO pin : Audio_SCL_Pin */
    GPIO_InitStruct.Pin = Audio_SCL_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
    HAL_GPIO_Init(Audio_SCL_GPIO_Port, &GPIO_InitStruct);

    /*Configure GPIO pin : MEMS_INT2_Pin */
    GPIO_InitStruct.Pin = MEMS_INT2_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(MEMS_INT2_GPIO_Port, &GPIO_InitStruct);

    /* USER CODE BEGIN MX_GPIO_Init_2 */

    /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */
static void* memAllocate(CanardInstance* const ins, const size_t amount)
{
    (void)ins;
    return malloc(amount);
}

static void memFree(CanardInstance* const ins, void* const pointer)
{
    (void)ins;
    free(pointer);
}

void process_canard_TX_queue(void)
{
    // Process TX queue with timeout to prevent blocking
    const uint32_t timeout_ms = 10;  // 10ms timeout
    uint32_t start_time = HAL_GetTick();
    
    for (const CanardCANFrame* txf = NULL; (txf = canardPeekTxQueue(&canard)) != NULL;) {
        // Check if we've exceeded our timeout
        if (HAL_GetTick() - start_time >= timeout_ms) {
            printf("TX queue processing timeout - will continue next cycle\r\n");
            break;
        }
        
        CAN_TxHeaderTypeDef tx_header;
        uint32_t tx_mailbox;
        
        tx_header.StdId = 0;
        tx_header.ExtId = txf->id & CANARD_CAN_EXT_ID_MASK;
        tx_header.IDE = CAN_ID_EXT;
        tx_header.RTR = CAN_RTR_DATA;
        tx_header.DLC = txf->data_len;
        
        // Try to send the frame with a short timeout
        if (HAL_CAN_AddTxMessage(&hcan1, &tx_header, (uint8_t*)txf->data, &tx_mailbox) == HAL_OK) {
            // Success - remove from queue
            canardPopTxQueue(&canard);
            
            // Print debug info
            printf("CAN TX: EXT ID=0x%08lx, DLC=%lu data=[", 
                   (unsigned long)tx_header.ExtId, (unsigned long)tx_header.DLC);
            for (int i = 0; i < tx_header.DLC; i++) {
                printf("%02x ", ((uint8_t*)txf->data)[i]);
            }
            printf("]\r\n");
        } else {
            // Failed to send - break and try again next time
            printf("CAN TX failed - will retry next cycle\r\n");
            break;
        }
    }
}



void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)
{
    CAN_RxHeaderTypeDef rx_header;
    uint8_t rx_data[8];
    
    if (HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &rx_header, rx_data) != HAL_OK)
    {
        printf("CAN RX: Error getting message from FIFO0\r\n");
        return;
    }
    
    // Decode message ID early to filter out problematic messages
    if (rx_header.IDE == CAN_ID_EXT) {
        uint8_t source_node_id = rx_header.ExtId & 0x7F;
        uint32_t message_id = (rx_header.ExtId >> 8) & 0xFFFF;
        
        // Skip processing of known problematic message types
        if (message_id == 0x0000 || message_id == ARDUPILOT_GNSS_STATUS_ID) {
            printf("Skipping problematic message ID 0x%04x from node %d\r\n", 
                  (unsigned int)message_id, source_node_id);
            return;  // Exit this function early
        }
    }
    
    // Toggle orange LED (LD3) to show RX activity
    can_rx_led = !can_rx_led;
    HAL_GPIO_WritePin(LD3_GPIO_Port, LD3_Pin, can_rx_led ? GPIO_PIN_SET : GPIO_PIN_RESET);
    
    // Record reception timestamp 
    uint64_t timestamp_usec = micros64();
    
    // Print detailed information about the received CAN message
    if (rx_header.IDE == CAN_ID_EXT) {
        // Only log DroneCAN-like extended ID frames
        // Decode the UAVCAN message ID and other fields
        // UAVCAN CAN ID format: 
        // bits 0-6: Source node ID (7 bits)
        // bit 7: Service not message flag (1 bit)
        // bits 8-23: Service/Message ID (16 bits)
        // bits 24-28: Priority (5 bits)
        // bits 29-31: Frame format flags
        uint8_t source_node_id = rx_header.ExtId & 0x7F;
        bool is_service = (rx_header.ExtId >> 7) & 1;
        uint32_t message_id = (rx_header.ExtId >> 8) & 0xFFFF;
        uint8_t priority = (rx_header.ExtId >> 24) & 0x1F;
        
        // Only log important messages or errors
        if (message_id == UAVCAN_EQUIPMENT_ACTUATOR_ARRAYCOMMAND_ID) {
            // Only log ArrayCommand messages (ID 1010)
            printf("ArrayCmd from node %d (DLC=%d)\r\n", source_node_id, rx_header.DLC);
        } else if (rx_header.DLC < 2) {
            // Log suspiciously small frames
            printf("SHORT CAN RX: ID=0x%08lx, DLC=%lu\r\n", 
                   (unsigned long)rx_header.ExtId, (unsigned long)rx_header.DLC);
        } else if (message_id == ARDUPILOT_GNSS_STATUS_ID) {
            // Skip logging for common messages like ID 20007
            // It's a very common message that floods the logs
        } else {
            // Only log the basic message info, not the data
            static uint32_t msg_count = 0;
            if (msg_count++ % 20 == 0) {  // Only log every 20th message
                printf("CAN RX: ID=0x%04x, src=%d, pri=%d\r\n", 
                       (unsigned int)message_id, source_node_id, priority);
            }
        }
    }
    
    // Prepare the frame structure for Canard
    CanardCANFrame frame;
    
    // Set ID and flags
    if (rx_header.IDE == CAN_ID_EXT) {
        // Extended ID frame with the CANARD_CAN_FRAME_EFF flag set
        frame.id = rx_header.ExtId | CANARD_CAN_FRAME_EFF;
    } else {
        // Standard ID frame
        frame.id = rx_header.StdId;
    }
    
    // Set RTR flag if this is a remote frame
    if (rx_header.RTR == CAN_RTR_REMOTE) {
        frame.id |= CANARD_CAN_FRAME_RTR;
    }
    
    // Copy data and set timestamp
    frame.data_len = rx_header.DLC;
    memcpy(frame.data, rx_data, frame.data_len);
    
    // Process the received frame with Canard
    int result = canardHandleRxFrame(&canard, &frame, timestamp_usec);
    
    if (result < 0) {
        // If there was an error processing the frame, log detailed information
        printf("CAN RX: Error %d processing frame, message type: 0x%04x, source: %u\r\n", 
               result, (uint16_t)((rx_header.ExtId >> 8) & 0xFFFF), (unsigned int)(rx_header.ExtId & 0x7F));
    }
    
    // Check if this is a SDO read response for position
    if (rx_header.StdId == (EPOS4_SDO_READ_REPLY + EPOS4_NODE_ID)) {
        // Feed watchdog during message processing
        IWDG->KR = 0xAAAA;
        
        if (rx_data[0] == 0x43 &&  // Read response
            rx_data[1] == (EPOS4_ACTUAL_POSITION_INDEX & 0xFF) &&
            rx_data[2] == ((EPOS4_ACTUAL_POSITION_INDEX >> 8) & 0xFF) &&
            rx_data[3] == EPOS4_ACTUAL_POSITION_SUBINDEX) {
            
            // Extract position value (4 bytes, little-endian)
            int32_t position_value = (int32_t)rx_data[4] |
                                  ((int32_t)rx_data[5] << 8) |
                                  ((int32_t)rx_data[6] << 16) |
                                  ((int32_t)rx_data[7] << 24);
            
            // Update global position variable
            current_position = position_value;
            
            // Only log position occasionally to reduce spam
            static uint32_t position_log_counter = 0;
            if (position_log_counter++ % 10 == 0) {
                printf("EPOS4 Position: %ld\r\n", (long)current_position);
            }
            
            // Update position parameter with normalized value
            param_t* pos_param = getParamByName("epos4.pos");
            if (pos_param != NULL) {
                pos_param->value.f = translateEPOS4Position(current_position);
            }
        }
        // Check for statusword response
        else if (rx_data[0] == 0x4B &&  // Read response (2 bytes)
                rx_data[1] == (EPOS4_STATUSWORD_INDEX & 0xFF) &&
                rx_data[2] == ((EPOS4_STATUSWORD_INDEX >> 8) & 0xFF) &&
                rx_data[3] == 0x00) {  // Subindex 0
            
            // Extract the statusword (2 bytes, little-endian)
            uint16_t statusword = (uint16_t)rx_data[4] | ((uint16_t)rx_data[5] << 8);
            
            // Interpret the EPOS4 statusword bits
            printf("EPOS4 Statusword: 0x%04X\r\n", statusword);
            
            // Bit analysis (according to CANopen specs)
            printf("  Ready to switch on: %s\r\n", (statusword & 0x0001) ? "Yes" : "No");
            printf("  Switched on: %s\r\n", (statusword & 0x0002) ? "Yes" : "No");
            printf("  Operation enabled: %s\r\n", (statusword & 0x0004) ? "Yes" : "No");
            printf("  Fault: %s\r\n", (statusword & 0x0008) ? "Yes" : "No");
            printf("  Voltage enabled: %s\r\n", (statusword & 0x0010) ? "Yes" : "No");
            printf("  Quick stop: %s\r\n", (statusword & 0x0020) ? "No" : "Yes");  // Inverted logic
            printf("  Switch on disabled: %s\r\n", (statusword & 0x0040) ? "Yes" : "No");
            printf("  Warning: %s\r\n", (statusword & 0x0080) ? "Yes" : "No");
            
            // Check for specific error states
            if (statusword & 0x0008) {
                printf("ERROR: EPOS4 is in FAULT state - motor movement disabled\r\n");
                printf("       Reset the controller or clear faults to continue\r\n");
            } else if (!(statusword & 0x0004)) {
                printf("ERROR: EPOS4 operation not enabled - motor won't move\r\n");
                printf("       Enable operation with controlword 0x000F\r\n");
                
                // Attempt to enable operation
                printf("Attempting to re-enable operation...\r\n");
                epos4_enable_motor();
            }
        }
        // Also check for generic SDO responses to handle errors
        else if ((rx_data[0] & 0x80) == 0x80) {
            // This is an SDO abort message
            uint32_t abort_code = (uint32_t)rx_data[4] |
                              ((uint32_t)rx_data[5] << 8) |
                              ((uint32_t)rx_data[6] << 16) |
                              ((uint32_t)rx_data[7] << 24);
            
            printf("EPOS4 SDO error: 0x%08lX\r\n", (unsigned long)abort_code);
            
            // Blink red LED to indicate error
            HAL_GPIO_TogglePin(LD5_GPIO_Port, LD5_Pin);
        }
        else if (rx_data[0] == 0x60) {
            // This is a positive acknowledgment (write confirmation)
            printf("EPOS4 SDO write confirmed\r\n");
        }
    }
}

void HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef *hcan)
{
    // Similar to FIFO0 callback if needed
}

// Change this from static to non-static to match declaration
void processTxRxOnce(CanardInstance *ins, uint32_t timeout_ms)
{
    // Feed the watchdog before starting
    IWDG->KR = 0xAAAA;
    
    // Set timeout for processing
    uint32_t start_time = HAL_GetTick();
    
    
    // Process outgoing transfers (from library to CAN driver)
    int tx_attempts = 0;  // Limit TX attempts to avoid getting stuck
    for (const CanardCANFrame* txf = NULL; tx_attempts < 5 && (txf = canardPeekTxQueue(ins)) != NULL; tx_attempts++)
    {
        // Check if we've exceeded the timeout
        if (timeout_ms > 0 && HAL_GetTick() - start_time > timeout_ms) {
            break;
        }
        
        // Feed watchdog during processing
        IWDG->KR = 0xAAAA;
        
        // Process an outbound CAN frame using the STM32 HAL
        CAN_TxHeaderTypeDef tx_header;
        uint32_t tx_mailbox;
        
        tx_header.StdId = 0;
        tx_header.ExtId = txf->id & CANARD_CAN_EXT_ID_MASK;
        tx_header.IDE = CAN_ID_EXT;
        tx_header.RTR = CAN_RTR_DATA;
        tx_header.DLC = txf->data_len;
        
        // Print detailed information about the CAN message being sent
        uint16_t data_type_id = (txf->id >> 8) & 0xFFFF;
        
        // Short timeout attempt to send message
        HAL_StatusTypeDef status = HAL_CAN_AddTxMessage(&hcan1, &tx_header, (uint8_t*)txf->data, &tx_mailbox);
        
        if (status == HAL_OK) {
            // Remove from queue only if sent successfully
            canardPopTxQueue(ins);
        } else {
            // Break out if TX mailboxes are full
            break;
        }
    }
    
    // Feed watchdog again
    IWDG->KR = 0xAAAA;
    
    // Check for received CAN frames
    {
        // Check if there are pending messages
        if (HAL_CAN_GetRxFifoFillLevel(&hcan1, CAN_RX_FIFO0) > 0)
        {
            // Process the pending message
            HAL_CAN_RxFifo0MsgPendingCallback(&hcan1);
        }
    }
    
    // Feed watchdog one more time
    IWDG->KR = 0xAAAA;
}

// Change this from static to non-static to match declaration
void send_NodeStatus(void)
{
    printf("Sending heartbeat message\r\n");
    // Prepare the message
    uint8_t buffer[UAVCAN_NODE_STATUS_MESSAGE_SIZE];
    memset(buffer, 0, UAVCAN_NODE_STATUS_MESSAGE_SIZE);
    
    // Set the status fields
    uint32_t uptime_sec = HAL_GetTick() / 1000;
    memcpy(&buffer[0], &uptime_sec, 4);
    
    // Health: 0 = NOMINAL, no health alerts
    buffer[4] = UAVCAN_NODE_HEALTH_OK;
    
    // Mode: 0 = OPERATIONAL, we're running fine
    buffer[5] = UAVCAN_NODE_MODE_OPERATIONAL;
    
    // Sub-mode is unused (0)
    buffer[6] = 0;
    
    // Vendor-specific status code - use to indicate EPOS4 status
    buffer[7] = 0;  // Default to 0 for normal operation
    
    // Break signature into two 32-bit parts for printing to avoid platform-specific issues
    uint32_t sig_high = (uint32_t)(UAVCAN_NODE_STATUS_DATA_TYPE_SIGNATURE >> 32);
    uint32_t sig_low = (uint32_t)(UAVCAN_NODE_STATUS_DATA_TYPE_SIGNATURE & 0xFFFFFFFF);

    // Debug print the message contents
    printf("Heartbeat message details:\r\n");
    printf("Uptime: %lu seconds\r\n", (unsigned long)uptime_sec);
    printf("Health: %u (0=NOMINAL)\r\n", buffer[4]);
    printf("Mode: %u (0=OPERATIONAL)\r\n", buffer[5]);
    printf("Sub-mode: %u\r\n", buffer[6]);
    printf("Vendor status: %u\r\n", buffer[7]);
    printf("Message type ID: %u (0x%x)\r\n", UAVCAN_NODE_STATUS_DATA_TYPE_ID, UAVCAN_NODE_STATUS_DATA_TYPE_ID);
    printf("Message signature: 0x%08lx%08lx\r\n", (unsigned long)sig_high, (unsigned long)sig_low);
    printf("Message size: %u bytes\r\n", UAVCAN_NODE_STATUS_MESSAGE_SIZE);

    // Print raw message bytes
    printf("Raw message bytes: ");
    for(int i = 0; i < UAVCAN_NODE_STATUS_MESSAGE_SIZE; i++) {
        printf("%02x ", buffer[i]);
    }
    printf("\r\n");

    // Send as broadcast
    int result = canardBroadcast(&canard,
                                UAVCAN_NODE_STATUS_DATA_TYPE_SIGNATURE,
                                UAVCAN_NODE_STATUS_DATA_TYPE_ID,
                                &transfer_id,
                                CANARD_TRANSFER_PRIORITY_MEDIUM,
                                buffer,
                                UAVCAN_NODE_STATUS_MESSAGE_SIZE);
    
    printf("Broadcast result: %d", result);
    if (result < 0) {
        printf(" (ERROR: %d - check CAN bus)", result);
    } else if (result == 0) {
        printf(" (OK - IMMEDIATE TX)");
    } else if (result > 0) {
        printf(" (OK - QUEUED)");
    }
    printf("\r\n");

    // Add delay after sending heartbeat
    HAL_Delay(1);  // Small delay to allow transmission
}

static bool shouldAcceptTransfer(const CanardInstance* ins,
                                  uint64_t* out_data_type_signature,
                                  uint16_t data_type_id,
                                  CanardTransferType transfer_type,
                                  uint8_t source_node_id)
{
    // Debug print for all received transfers
    printf("DEBUG: Transfer received - data_type_id=0x%04x, transfer_type=%d, source_node_id=%d\r\n",
           data_type_id, (int)transfer_type, source_node_id);
           
    // Accept messages from our own node ID
    if (source_node_id == NODE_ID) {
        printf("  Message from our own node ID %d\r\n", source_node_id);
        return true;
    }
    
    // Skip messages with ID 0x4e27 (ArduPilot GNSS status) as they cause -17 errors
    if (data_type_id == ARDUPILOT_GNSS_STATUS_ID) {
        // Return false to completely skip processing this message
        printf("  Ignoring ArduPilot GNSS status message from node %d to avoid errors\r\n", source_node_id);
        return false;
    }
    
    // Accept GetNodeInfo request/response
    if (transfer_type == CanardTransferTypeRequest &&
        data_type_id == UAVCAN_PROTOCOL_GETNODEINFO_ID) {
        printf("  GetNodeInfo request detected from node %d (data_type_id=0x%04x)\r\n", 
               source_node_id, data_type_id);
        
        // Handle broadcast address specially (commonly used by Mission Planner)
        if (source_node_id == 127) {
            printf("  Detected GetNodeInfo from broadcast address (ID 127) - likely Mission Planner discovery\r\n");
        }
        
        // Use the correct signature value defined in the header
        *out_data_type_signature = UAVCAN_PROTOCOL_GETNODEINFO_SIGNATURE;
        
        // Print the actual value to verify it's not zero
        printf("  Using GetNodeInfo signature: 0x%llx\r\n", 
               (unsigned long long)*out_data_type_signature);
               
        printf("  ACCEPTING GetNodeInfo transfer\r\n");
        return true;
    }
    
    // Accept parameter get/set requests
    if (transfer_type == CanardTransferTypeRequest && 
        data_type_id == UAVCAN_PROTOCOL_PARAM_GETSET_ID) {
        printf("  Parameter get/set request from node %d (data_type_id=0x%04x)\r\n", 
               source_node_id, data_type_id);
        *out_data_type_signature = UAVCAN_PARAM_GETSET_SIGNATURE;
        printf("  ACCEPTING parameter get/set transfer\r\n");
        return true;
    }
    
    // Accept NodeStatus messages from any node for monitoring
    if (transfer_type == CanardTransferTypeMessage &&
        data_type_id == UAVCAN_PROTOCOL_NODE_STATUS_MESSAGE_ID) {
        *out_data_type_signature = UAVCAN_NODE_STATUS_DATA_TYPE_SIGNATURE;
        printf("  NodeStatus message (ID=%u) from node %d - ACCEPTING\r\n", 
               data_type_id, source_node_id);
        return true;
    }
    
    // Accept actuator array command messages with correct signature
    if (transfer_type == CanardTransferTypeMessage && data_type_id == UAVCAN_EQUIPMENT_ACTUATOR_ARRAYCOMMAND_ID) {
        *out_data_type_signature = UAVCAN_EQUIPMENT_ACTUATOR_ARRAYCOMMAND_SIGNATURE;
        printf("  Actuator ArrayCommand (ID %u) from node %d - ACCEPTING\r\n", data_type_id, source_node_id);
        return true;
    }
    
    printf("  Not for our node ID (our ID is %d)\r\n", NODE_ID);
    return false;
}
void readUniqueID(uint8_t* out_uid)
{
    for (uint8_t i = 0; i < UNIQUE_ID_LENGTH_BYTES; i++)
    {
        out_uid[i] = i;
    }
}
// Handle GetNodeInfo service request
void handle_get_node_info(CanardInstance* ins, CanardRxTransfer* transfer)
{
    printf("Processing GetNodeInfo request from node %d\r\n", transfer->source_node_id);
    
     uint8_t buffer[UAVCAN_GET_NODE_INFO_RESPONSE_MAX_SIZE];
        memset(buffer,0,UAVCAN_GET_NODE_INFO_RESPONSE_MAX_SIZE);
        uint16_t len = makeNodeInfoMessage(buffer);
        int result = canardRequestOrRespond(ins,
                                            transfer->source_node_id,
                                            UAVCAN_GET_NODE_INFO_DATA_TYPE_SIGNATURE,
                                            UAVCAN_GET_NODE_INFO_DATA_TYPE_ID,
                                            &transfer->transfer_id,
                                            transfer->priority,
                                            CanardResponse,
                                            &buffer[0],
                                            (uint16_t)len);
}
uint16_t makeNodeInfoMessage(uint8_t buffer[UAVCAN_GET_NODE_INFO_RESPONSE_MAX_SIZE])
{
    memset(buffer, 0, UAVCAN_GET_NODE_INFO_RESPONSE_MAX_SIZE);
    makeNodeStatusMessage(buffer);
   
    buffer[7] = APP_VERSION_MAJOR;
    buffer[8] = APP_VERSION_MINOR;
    buffer[9] = 1;                          // Optional field flags, VCS commit is set
    uint32_t u32 = GIT_HASH;
    canardEncodeScalar(buffer, 80, 32, &u32); 
    
    readUniqueID(&buffer[24]);
    const size_t name_len = strlen(APP_NODE_NAME);
    memcpy(&buffer[41], APP_NODE_NAME, name_len);
    return 41 + name_len ;
}
void makeNodeStatusMessage(uint8_t buffer[UAVCAN_NODE_STATUS_MESSAGE_SIZE])
{
    uint8_t node_health = UAVCAN_NODE_HEALTH_OK;
    uint8_t node_mode   = UAVCAN_NODE_MODE_OPERATIONAL;
    memset(buffer, 0, UAVCAN_NODE_STATUS_MESSAGE_SIZE);
    uint32_t uptime_sec = (HAL_GetTick() / 1000);
    canardEncodeScalar(buffer,  0, 32, &uptime_sec);
    canardEncodeScalar(buffer, 32,  2, &node_health);
    canardEncodeScalar(buffer, 34,  3, &node_mode);
}

void onTransferReceived(CanardInstance* ins, CanardRxTransfer* transfer)
{
    // Feed the watchdog during message processing to prevent resets
    IWDG->KR = 0xAAAA;
    
    printf("RECEIVED Transfer: data_type_id=%d, transfer_type=%d, source_node=%d\r\n",
           (int)transfer->data_type_id, (int)transfer->transfer_type, transfer->source_node_id);
           
    // Handle GetNodeInfo request
    if ((transfer->transfer_type == CanardTransferTypeRequest) &&
        (transfer->data_type_id == UAVCAN_PROTOCOL_GETNODEINFO_ID))
    {
        printf("INFO: GetNodeInfo request from node %d (signature: 0x%016llX)\r\n", 
               transfer->source_node_id, UAVCAN_PROTOCOL_GETNODEINFO_SIGNATURE);
        
        // Special handling for broadcast requests (typically from Mission Planner)
        if (transfer->source_node_id == 127) {
            printf("INFO: Received broadcast GetNodeInfo request - normal for Mission Planner\r\n");
            printf("INFO: Will respond with node info (node_id=%d)\r\n", NODE_ID);
        }
        
        handle_get_node_info(ins, transfer);
    }
    // Handle GetNodeInfo response
    else if ((transfer->transfer_type == CanardTransferTypeResponse) &&
             (transfer->data_type_id == UAVCAN_PROTOCOL_GETNODEINFO_ID))
    {
        printf("INFO: Received GetNodeInfo response from node %d\r\n", transfer->source_node_id);
        
        // Parse the response if we have enough data
        if (transfer->payload_len >= 7)  // Minimum size for node status
        {
            uint32_t uptime_sec = 0;
            uint8_t health = 0;
            uint8_t mode = 0;
            uint8_t sub_mode = 0;
            
            canardDecodeScalar(transfer, 0, 32, false, &uptime_sec);
            canardDecodeScalar(transfer, 32, 8, false, &health);
            canardDecodeScalar(transfer, 40, 8, false, &mode);
            canardDecodeScalar(transfer, 48, 8, false, &sub_mode);
            
            printf("  Node Status:\r\n");
            printf("    Uptime: %lu seconds\r\n", uptime_sec);
            printf("    Health: %u\r\n", health);
            printf("    Mode: %u\r\n", mode);
            printf("    Sub-mode: %u\r\n", sub_mode);
            
            // Try to parse version info if available
            if (transfer->payload_len >= 17)  // +10 bytes for version info
            {
                uint8_t protocol_version = 0;
                uint8_t hw_version_major = 0;
                uint8_t hw_version_minor = 0;
                uint8_t sw_version_major = 0;
                uint8_t sw_version_minor = 0;
                uint32_t sw_vcs_commit = 0;
                
                canardDecodeScalar(transfer, 56, 8, false, &protocol_version);
                canardDecodeScalar(transfer, 64, 8, false, &hw_version_major);
                canardDecodeScalar(transfer, 72, 8, false, &hw_version_minor);
                canardDecodeScalar(transfer, 80, 8, false, &sw_version_major);
                canardDecodeScalar(transfer, 88, 8, false, &sw_version_minor);
                canardDecodeScalar(transfer, 96, 32, false, &sw_vcs_commit);
                
                printf("  Version Info:\r\n");
                printf("    Protocol: %u\r\n", protocol_version);
                printf("    Hardware: %u.%u\r\n", hw_version_major, hw_version_minor);
                printf("    Software: %u.%u (VCS: %lu)\r\n", 
                       sw_version_major, sw_version_minor, sw_vcs_commit);
            }
        }
        else
        {
            printf("WARNING: GetNodeInfo response too short (%u bytes)\r\n", 
                   transfer->payload_len);
        }
    }
    
    // Handle NodeStatus messages
    else if ((transfer->transfer_type == CanardTransferTypeMessage) && 
             (transfer->data_type_id == UAVCAN_PROTOCOL_NODE_STATUS_MESSAGE_ID))
    {
        // Parse the received NodeStatus message
        // According to UAVCAN protocol, a NodeStatus message has the following structure:
        // - Uptime (32 bits)
        // - Health (8 bits)
        // - Mode (8 bits)
        // - Sub-mode (8 bits)
        // - Vendor-specific status code (16 bits)
        if (transfer->payload_len >= 7)
        {
            uint32_t uptime = 0;
            uint8_t health = 0;
            uint8_t mode = 0;
            uint8_t sub_mode = 0;
            uint16_t vendor_status = 0;
            
            // Extract data using canardDecodeScalar
            canardDecodeScalar(transfer, 0, 32, false, &uptime);
            canardDecodeScalar(transfer, 32, 8, false, &health);
            canardDecodeScalar(transfer, 40, 8, false, &mode); 
            canardDecodeScalar(transfer, 48, 8, false, &sub_mode);
            
            if (transfer->payload_len >= 9)
            {
                canardDecodeScalar(transfer, 56, 16, false, &vendor_status);
            }
            
            // Interpret the health field
            const char* health_str = "UNKNOWN";
            switch (health)
            {
                case 0: health_str = "NOMINAL"; break;
                case 1: health_str = "WARNING"; break;
                case 2: health_str = "ERROR"; break;
                case 3: health_str = "CRITICAL"; break;
            }
            
            // Interpret the mode field
            const char* mode_str = "UNKNOWN";
            switch (mode)
            {
                case 0: mode_str = "OPERATIONAL"; break;
                case 1: mode_str = "INITIALIZATION"; break;
                case 2: mode_str = "MAINTENANCE"; break;
                case 3: mode_str = "SOFTWARE_UPDATE"; break;
                case 7: mode_str = "OFFLINE"; break;
            }
            
            // Print the interpreted message in a readable format
            printf("RECEIVED NodeStatus message from node %d:\r\n", transfer->source_node_id);
            printf("  Uptime: %lu seconds\r\n", uptime);
            printf("  Health: %u (%s)\r\n", health, health_str);
            printf("  Mode: %u (%s)\r\n", mode, mode_str);
            printf("  Sub-mode: %u\r\n", sub_mode);
            printf("  Vendor status: %u\r\n", vendor_status);
        }
        else
        {
            printf("WARNING: Received a truncated NodeStatus message from node %d\r\n", 
                   transfer->source_node_id);
        }
    }
    
    // Handle custom message ID 1010 (UAVCAN_LOCAL_NODE_STATUS)
    else if ((transfer->transfer_type == CanardTransferTypeMessage) && 
             (transfer->data_type_id == UAVCAN_EQUIPMENT_ACTUATOR_ARRAYCOMMAND_ID))
    {
        printf("RECEIVED Actuator Array Command from node %d\r\n", transfer->source_node_id);
        // Process the actuator command message
        handleActuatorArrayCommand(ins, transfer);
    }
    
    // Handle parameter get/set requests
    else if ((transfer->transfer_type == CanardTransferTypeRequest) && 
             (transfer->data_type_id == UAVCAN_PROTOCOL_PARAM_GETSET_ID))
    {
        printf("Handling parameter get/set request from node ID: %d\r\n", transfer->source_node_id);
        handle_param_getset(ins, transfer);
    }
    
    // Handle ArduPilot GNSS status message - Fix for message type 0x4e27 (20007)
    else if ((transfer->transfer_type == CanardTransferTypeMessage) && 
             (transfer->data_type_id == ARDUPILOT_GNSS_STATUS_ID))
    {
        // Skip detailed processing of this message type to avoid issues
        // Just acknowledge receipt and don't try to decode it
        printf("Received ArduPilot GNSS status from node %d (skipping detailed processing)\r\n", 
               transfer->source_node_id);
    }
    
    // Log messages we're not handling specifically
    else
    {
        printf("Received unhandled transfer: data_type_id=%u, transfer_type=%u, source_node=%u\r\n",
               transfer->data_type_id, transfer->transfer_type, transfer->source_node_id);
    }
}

/**
 * Tasks to run at 1Hz (and other low frequencies)
 */
void process1HzTasks(uint64_t timestamp_usec)
{
    static uint64_t last_1hz_task_ms = 0;
    static uint64_t last_actuator_status_ms = 0;
    static uint64_t last_position_read_ms = 0;
    static uint64_t last_param_broadcast_ms = 0;
    static uint8_t param_broadcast_counter = 0;
    
    // Get current time in milliseconds
    uint64_t current_ms = timestamp_usec / 1000;
    
    // Read position every 50ms (20Hz)
    if (current_ms - last_position_read_ms >= 50) {
        epos4_read_position(EPOS4_ACTUAL_POSITION_INDEX, EPOS4_ACTUAL_POSITION_SUBINDEX);
        last_position_read_ms = current_ms;
    }
    
    // 1Hz tasks
    if (current_ms - last_1hz_task_ms >= 1000) {
        // Send node status message
        send_NodeStatus();
        
        // Broadcast a parameter every second to help with discovery
        if (param_broadcast_counter < MAX_PARAMETERS && parameters[param_broadcast_counter].name[0] != '\0') {
            printf("Periodic parameter broadcast: %s\r\n", parameters[param_broadcast_counter].name);
            
            // Create parameter response buffer
            uint8_t buffer[UAVCAN_PROTOCOL_PARAM_VALUE_SIZE] = {0};
            int offset = 0;
            param_t* p = &parameters[param_broadcast_counter];
            
            // Encode based on type
            switch (p->type) {
                case PARAM_TYPE_INTEGER:
                    buffer[offset++] = PARAM_TYPE_INTEGER;  // Integer type tag
                    int64_t int_val = (int64_t)p->value.i;
                    memcpy(&buffer[offset], &int_val, sizeof(int64_t));
                    offset += sizeof(int64_t);
                    int64_t default_val = (int64_t)p->defval;
                    memcpy(&buffer[offset], &default_val, sizeof(int64_t));
                    offset += sizeof(int64_t);
                    int64_t min_val = (int64_t)p->min;
                    memcpy(&buffer[offset], &min_val, sizeof(int64_t));
                    offset += sizeof(int64_t);
                    int64_t max_val = (int64_t)p->max;
                    memcpy(&buffer[offset], &max_val, sizeof(int64_t));
                    offset += sizeof(int64_t);
                    break;
                
                case PARAM_TYPE_REAL:
                    buffer[offset++] = PARAM_TYPE_REAL;  // Real type tag
                    float real_val = p->value.f;
                    memcpy(&buffer[offset], &real_val, sizeof(float));
                    offset += sizeof(float);
                    float def_val_f = (float)p->defval;
                    memcpy(&buffer[offset], &def_val_f, sizeof(float));
                    offset += sizeof(float);
                    float min_val_f = (float)p->min;
                    memcpy(&buffer[offset], &min_val_f, sizeof(float));
                    offset += sizeof(float);
                    float max_val_f = (float)p->max;
                    memcpy(&buffer[offset], &max_val_f, sizeof(float));
                    offset += sizeof(float);
                    break;
                
                case PARAM_TYPE_STRING: {
                    buffer[offset++] = PARAM_TYPE_STRING;
                    
                    // First string is empty (default value)
                    buffer[offset++] = 0;
                    
                    // Second string is the actual value
                    uint8_t str_len = strlen(p->value.str);
                    buffer[offset++] = str_len;
                    memcpy(&buffer[offset], p->value.str, str_len);
                    offset += str_len;
                    
                    // Third string is empty (min value - not used for strings)
                    buffer[offset++] = 0;
                    
                    // Fourth string is empty (max value - not used for strings)
                    buffer[offset++] = 0;
                    break;
                }
                
                default:
                    buffer[offset++] = PARAM_TYPE_EMPTY;  // Empty type tag
                    break;
            }
            
            // Add parameter name at the end
            uint8_t name_len = strlen(p->name);
            buffer[offset++] = name_len;
            memcpy(&buffer[offset], p->name, name_len);
            offset += name_len;
            
            // Add parameter index
            buffer[offset++] = param_broadcast_counter & 0xFF;
            buffer[offset++] = (param_broadcast_counter >> 8) & 0xFF;
            
            // Send parameter with high priority
            static uint8_t transfer_id = 0;
            canardRequestOrRespond(&canard,
                                  CANARD_BROADCAST_NODE_ID,
                                  UAVCAN_PARAM_GETSET_SIGNATURE,
                                  UAVCAN_PROTOCOL_PARAM_GETSET_ID,
                                  &transfer_id,
                                  CANARD_TRANSFER_PRIORITY_HIGH,
                                  CanardResponse,
                                  buffer,
                                  offset);
            
            // Process TX queue to ensure it's sent
            processTxRxOnce(&canard, 0);
            
            // Move to next parameter
            param_broadcast_counter++;
            
            // Reset counter if we've gone through all parameters
            if (param_broadcast_counter >= MAX_PARAMETERS) {
                param_broadcast_counter = 0;
            }
        }
        
        last_1hz_task_ms = current_ms;
    }
    
    // 10Hz tasks for actuator status - 100ms interval
    if (current_ms - last_actuator_status_ms >= 100) {
        // Send actuator status message
        send_actuator_status();
        last_actuator_status_ms = current_ms;
    }
    
    // Periodically broadcast parameters every 5 seconds to help with discovery
    if (current_ms - last_param_broadcast_ms >= 5000) {
        // Full parameter broadcast every 5 seconds
        broadcast_all_parameters();
        last_param_broadcast_ms = current_ms;
    }
}



void epos4_send_sdo_read(uint16_t index, uint8_t subindex)
{
    CAN_TxHeaderTypeDef tx_header;
    uint32_t tx_mailbox;
    uint8_t tx_data[8] = {0};
    
    // Prepare SDO read message
    tx_data[0] = 0x40;  // Command to read
    tx_data[1] = (uint8_t)(index & 0xFF);         // Index LSB
    tx_data[2] = (uint8_t)((index >> 8) & 0xFF);  // Index MSB
    tx_data[3] = subindex;
    // Bytes 4-7 are reserved and should be 0
    
    tx_header.StdId = EPOS4_SDO_WRITE + EPOS4_NODE_ID;
    tx_header.ExtId = 0;
    tx_header.IDE = CAN_ID_STD;  // Standard ID, not extended
    tx_header.RTR = CAN_RTR_DATA;
    tx_header.DLC = 8;  // Always 8 bytes for SDO
    
    // Add delay before sending
        HAL_Delay(1);
    
    // Send the message
    HAL_CAN_AddTxMessage(&hcan1, &tx_header, tx_data, &tx_mailbox);
    
    // Add delay after sending
    HAL_Delay(1);
    
    // Blink orange LED (LD3) to indicate EPOS4 communication
    HAL_GPIO_TogglePin(LD3_GPIO_Port, LD3_Pin);
}

void epos4_set_operation_mode(uint8_t mode)
{
    // Set mode of operation (8-bit value)
    epos4_send_sdo_write(EPOS4_MODE_OF_OPERATION_INDEX, 0x00, mode, 1);
    
    // Wait a bit for the command to process
    HAL_Delay(10);
}

void epos4_set_target_velocity(int32_t target_velocity)
{
    // Set target velocity (32-bit value)
    epos4_send_sdo_write(EPOS4_TARGET_VELOCITY_INDEX, 0x00, (uint32_t)target_velocity, 4);
}

void epos4_set_target_position(int32_t target_position)
{
    // Feed watchdog before sending position command
    IWDG->KR = 0xAAAA;
    
    printf("Sending absolute position %ld to EPOS4\\r\\n", (long)target_position);
    
    // Special handling for center position (0) which seems to be problematic
    bool is_center_position = (target_position == 0);
    if (is_center_position) {
        printf("Center position handling with direct commands\\r\\n");
    }
    
    // STEP 1: First send SDO write to set target position (0x607A)
    CAN_TxHeaderTypeDef TxHeader1;
    uint8_t TxData1[8] = {0};
    uint32_t TxMailbox1;
    
    // Set up CAN message header
    TxHeader1.StdId = 0x600 + EPOS4_NODE_ID;  // SDO_RX_ID + nodeID
    TxHeader1.ExtId = 0;
    TxHeader1.RTR = CAN_RTR_DATA;
    TxHeader1.IDE = CAN_ID_STD;
    TxHeader1.DLC = 8;  // Always 8 bytes for SDO
    TxHeader1.TransmitGlobalTime = DISABLE;
    
    // Command byte: 0x23 = write 4 bytes (expedited transfer)
    TxData1[0] = 0x23;
    
    // Index (little endian)
    TxData1[1] = 0x7A;  // 0x607A LSB
    TxData1[2] = 0x60;  // 0x607A MSB
    
    // Subindex
    TxData1[3] = 0x00;
    
    // Position data (little endian)
    TxData1[4] = target_position & 0xFF;
    TxData1[5] = (target_position >> 8) & 0xFF;
    TxData1[6] = (target_position >> 16) & 0xFF;
    TxData1[7] = (target_position >> 24) & 0xFF;
    
    // Reset watchdog before sending
    IWDG->KR = 0xAAAA;
    
    // Send position command
    HAL_StatusTypeDef status1 = HAL_CAN_AddTxMessage(&hcan1, &TxHeader1, TxData1, &TxMailbox1);
    
    // Wait for message to be sent - max 50ms timeout
    uint32_t start_time = HAL_GetTick();
    uint32_t timeout_ms = 50;
    
    while (HAL_CAN_GetTxMailboxesFreeLevel(&hcan1) != 3 && HAL_GetTick() - start_time < timeout_ms) {
        // Feed watchdog while waiting
        IWDG->KR = 0xAAAA;
    }
    
    // Check if we timed out
    if (HAL_GetTick() - start_time >= timeout_ms) {
        printf("Timeout waiting for position command to be sent\\r\\n");
    }
    
    // Process any pending CAN messages
    processTxRxOnce(&canard, 1);
    
    // Additional delay only for non-zero positions (center position needs different handling)
    if (!is_center_position) {
        HAL_Delay(5);
    }
    
    // Reset watchdog before next command
    IWDG->KR = 0xAAAA;
    
    // STEP 2: Send control word with bit 4 set to trigger the motion
    CAN_TxHeaderTypeDef TxHeader2;
    uint8_t TxData2[8] = {0};
    uint32_t TxMailbox2;
    
    // Set up CAN message header
    TxHeader2.StdId = 0x600 + EPOS4_NODE_ID;  // SDO_RX_ID + nodeID
    TxHeader2.ExtId = 0;
    TxHeader2.RTR = CAN_RTR_DATA;
    TxHeader2.IDE = CAN_ID_STD;
    TxHeader2.DLC = 8;  // Always 8 bytes for SDO
    TxHeader2.TransmitGlobalTime = DISABLE;
    
    // Command byte: 0x2B = write 2 bytes (expedited transfer)
    TxData2[0] = 0x2B;
    
    // Index (little endian)
    TxData2[1] = 0x40;  // 0x6040 LSB
    TxData2[2] = 0x60;  // 0x6040 MSB
    
    // Subindex
    TxData2[3] = 0x00;
    
    // Control word: 0x000F (enable operation) + 0x0010 (bit 4 = start motion) = 0x001F
    TxData2[4] = 0x1F;  // 0x001F LSB
    TxData2[5] = 0x00;  // 0x001F MSB
    TxData2[6] = 0x00;
    TxData2[7] = 0x00;
    
    // Reset watchdog before sending control word
    IWDG->KR = 0xAAAA;
    
    printf("Sending controlword to trigger motion\\r\\n");
    
    // Send control word to start motion
    HAL_StatusTypeDef status2 = HAL_CAN_AddTxMessage(&hcan1, &TxHeader2, TxData2, &TxMailbox2);
    
    // Wait for message to be sent - max 50ms timeout
    start_time = HAL_GetTick();
    while (HAL_CAN_GetTxMailboxesFreeLevel(&hcan1) != 3 && HAL_GetTick() - start_time < timeout_ms) {
        // Feed watchdog while waiting
        IWDG->KR = 0xAAAA;
    }
    
    // Check if we timed out
    if (HAL_GetTick() - start_time >= timeout_ms) {
        printf("Timeout waiting for control word command to be sent\\r\\n");
    }
    
    // Reset watchdog after sending commands
    IWDG->KR = 0xAAAA;
    
    // Process any pending CAN messages
    processTxRxOnce(&canard, 1);
    
    if (status1 == HAL_OK && status2 == HAL_OK) {
        printf("Position command sent and motion triggered\\r\\n");
    } else {
        printf("Error sending position command: status1=%d, status2=%d\\r\\n", status1, status2);
    }
    
    // Update stored position value for monitoring
    current_position = target_position;
    
    // Update position parameter
    param_t* pos_param = getParamByName("epos4.pos");
    if (pos_param != NULL) {
        pos_param->value.f = translateEPOS4Position(target_position);
    }
    
    // Feed watchdog again after sending command
    IWDG->KR = 0xAAAA;
    
    // REMOVED: Do not read statusword after command - this was causing the system to get stuck
    // Instead, just print a message and return
    if (is_center_position) {
        printf("Center position command completed - continuing without status check\\r\\n");
    }
}

void epos4_enable_motor(void)
{
    // Write controlword to enable operation (0x000F)
    // 0x06: Shutdown (prepare for enable)
    epos4_send_sdo_write(EPOS4_CONTROLWORD_INDEX, 0x00, 0x06, 2);
    HAL_Delay(10);
    
    // 0x07: Switch on
    epos4_send_sdo_write(EPOS4_CONTROLWORD_INDEX, 0x00, 0x07, 2);
    HAL_Delay(10);
    
    // 0x0F: Enable operation
    epos4_send_sdo_write(EPOS4_CONTROLWORD_INDEX, 0x00, 0x0F, 2);
    HAL_Delay(10);
    
    // Blink green LED (LD4) to indicate motor enabled
    HAL_GPIO_WritePin(LD4_GPIO_Port, LD4_Pin, GPIO_PIN_SET);
    HAL_Delay(100);
    HAL_GPIO_WritePin(LD4_GPIO_Port, LD4_Pin, GPIO_PIN_RESET);
}

void epos4_disable_motor(void)
{
    // Write controlword to disable operation (0x0006)
    epos4_send_sdo_write(EPOS4_CONTROLWORD_INDEX, 0x00, 0x06, 2);
    
    // Blink red LED (LD5) to indicate motor disabled
    HAL_GPIO_WritePin(LD5_GPIO_Port, LD5_Pin, GPIO_PIN_SET);
    HAL_Delay(100);
    HAL_GPIO_WritePin(LD5_GPIO_Port, LD5_Pin, GPIO_PIN_RESET);
}

void epos4_send_pdo(uint16_t cob_id, uint8_t* data, uint8_t length)
{
    CAN_TxHeaderTypeDef tx_header;
    uint32_t tx_mailbox;
    
    // Configure CAN message
    tx_header.StdId = cob_id;
    tx_header.ExtId = 0;
    tx_header.IDE = CAN_ID_STD;  // Standard ID, not extended
    tx_header.RTR = CAN_RTR_DATA;
    tx_header.DLC = length;
    
    // Add delay before sending
    HAL_Delay(1);
    
    // Send the message
    HAL_CAN_AddTxMessage(&hcan1, &tx_header, data, &tx_mailbox);
    
    // Add delay after sending
    HAL_Delay(1);
    
    // Blink orange LED (LD3) to indicate EPOS4 communication
    HAL_GPIO_TogglePin(LD3_GPIO_Port, LD3_Pin);
}

void handle_ardupilot_command(int16_t command_value)
{
    // Added debugging to track command processing
    printf("Starting to process command value: %d\n", command_value);
    
    // Special handling for command value 0 (center position)
    if (command_value == 0) {
        printf("Center position command (0) received - setting to center\r\n");
        
        // Feed watchdog before sending command
        IWDG->KR = 0xAAAA;
        
        // Set max timeout for command processing to prevent infinite hanging
        uint32_t start_time = HAL_GetTick();
        uint32_t timeout_ms = 500; // 500ms timeout for center position
        
        // Direct approach - send the center position command and return
        epos4_set_target_position(0);
        
        // Just send status feedback directly with timeout handling
        uint32_t status_start = HAL_GetTick();
        if (HAL_GetTick() - start_time < timeout_ms) {
            send_actuator_status();
        }
        
        // Feed watchdog after all operations
        IWDG->KR = 0xAAAA;
        
        // Indicate command processed
        HAL_GPIO_TogglePin(GPIOD, LD4_Pin);
        printf("Center position command processing completed\r\n");
            return;
    }
    
    // For non-zero commands:
    // ArduPilot command values are in the range -10000 to 10000
    // Convert to normalized range -1.0 to 1.0
    float normalized_command = command_value / 10000.0f;
    
    // Clamp the value
    if (normalized_command < -1.0f) normalized_command = -1.0f;
    if (normalized_command > 1.0f) normalized_command = 1.0f;
    
    // Apply deadband near center for non-zero commands
    float deadband = COMMAND_DEADBAND / 10000.0f;
    if (normalized_command > -deadband && normalized_command < deadband) {
        normalized_command = 0.0f;
    } else if (normalized_command > 0) {
        normalized_command = (normalized_command - deadband) / (1.0f - deadband);
        } else {
        normalized_command = (normalized_command + deadband) / (1.0f - deadband);
    }
    
    // Set timeout for entire command processing
    uint32_t start_time = HAL_GetTick();
    uint32_t timeout_ms = 500; // 500ms timeout for general command processing
    
    // Convert normalized position to EPOS4 encoder position
    int32_t target_position = getNormalizedToEPOS4Position(normalized_command);
    printf("Calculated position: %ld\r\n", (long)target_position);
    
    // Send the target position to EPOS4
    printf("Sending position command to EPOS4...\r\n");
    if (HAL_GetTick() - start_time < timeout_ms) {
        epos4_set_target_position(target_position);
        printf("EPOS4 position command sent\r\n");
    }
    
    // Update position parameter (for monitoring)
    param_t* pos_param = getParamByName("epos4.pos");
    if (pos_param != NULL && HAL_GetTick() - start_time < timeout_ms) {
        pos_param->value.f = normalized_command;
        printf("Updated position parameter to %.2f\r\n", pos_param->value.f);
    } else {
        printf("WARNING: Could not find epos4.pos parameter or timeout occurred\r\n");
    }
    
    // Detailed debugging output
    printf("Command: %d → normalized: %.2f → EPOS4 pos: %ld\r\n", 
           command_value, normalized_command, (long)target_position);
    
    // Send actuator status for feedback with timeout check
    if (HAL_GetTick() - start_time < timeout_ms) {
        printf("Sending status feedback\r\n");
        send_actuator_status();
        printf("Status sent\r\n");
        } else {
        printf("Timeout occurred - skipping status feedback\r\n");
    }
    
    // Feed watchdog to prevent resets
    IWDG->KR = 0xAAAA;
        
    // Indicate command processed
    HAL_GPIO_TogglePin(GPIOD, LD4_Pin);
    printf("Command processing completed successfully\r\n");
}

// EPOS4 CANopen interface functions
bool EPOS4_SetTargetPosition_Legacy(CAN_HandleTypeDef* hcan, uint8_t node_id, int32_t position)
{
    uint8_t dlc = 4;
    uint8_t data[8] = {0};
    
    // Format SDO message for EPOS4 position control
    uint32_t can_id = 0x600 + node_id;  // 0x600 is the SDO transmit ID base
    
    // Format SDO write command
    data[0] = 0x23;  // SDO write command (2 bytes)
    data[1] = 0x7A;  // Index LSB (0x607A = target position)
    data[2] = 0x60;  // Index MSB
    data[3] = 0x00;  // Subindex
    
    // Format the position data (4 bytes, little-endian)
    data[4] = (uint8_t)(position & 0xFF);
    data[5] = (uint8_t)((position >> 8) & 0xFF);
    data[6] = (uint8_t)((position >> 16) & 0xFF);
    data[7] = (uint8_t)((position >> 24) & 0xFF);
    
    CAN_TxHeaderTypeDef TxHeader;
    TxHeader.StdId = can_id;
    TxHeader.ExtId = 0;
    TxHeader.RTR = CAN_RTR_DATA;
    TxHeader.IDE = CAN_ID_STD;
    TxHeader.DLC = 8;
    TxHeader.TransmitGlobalTime = DISABLE;
    
    uint32_t tx_mailbox;
    HAL_StatusTypeDef status = HAL_CAN_AddTxMessage(hcan, &TxHeader, data, &tx_mailbox);
    
    return (status == HAL_OK);
}

void EPOS4_SetControlWord(CAN_HandleTypeDef* hcan, uint8_t node_id, uint16_t control_word)
{
    uint8_t dlc = 2;
    uint8_t data[8] = {0};
    uint32_t can_id = 0x600 + node_id;  // SDO request ID
    
    // Command to write to object dictionary at 0x6040 (control word)
    data[0] = 0x2B;  // Write command (2=write, B=2 bytes)
    data[1] = 0x40;  // Object index low byte
    data[2] = 0x60;  // Object index high byte
    data[3] = 0x00;  // Subindex
    
    // Control word value in little-endian format
    data[4] = (uint8_t)(control_word & 0xFF);
    data[5] = (uint8_t)((control_word >> 8) & 0xFF);
    
    CAN_TxHeaderTypeDef TxHeader;
    TxHeader.StdId = can_id;
    TxHeader.ExtId = 0;
    TxHeader.RTR = CAN_RTR_DATA;
    TxHeader.IDE = CAN_ID_STD;
    TxHeader.DLC = 8;
    TxHeader.TransmitGlobalTime = DISABLE;
    
    uint32_t mailbox;
    HAL_CAN_AddTxMessage(hcan, &TxHeader, data, &mailbox);
    
    // Small delay to ensure message transmission
    HAL_Delay(5);
}

// Function to initialize the EPOS4 controller
bool EPOS4_Init_Legacy(CAN_HandleTypeDef* hcan, uint8_t node_id)
{
    // Reset communication
    EPOS4_SetControlWord(hcan, node_id, 0x0080);  // Fault reset
    HAL_Delay(10);
    
    // Set mode of operation (Profile Position Mode)
    uint8_t data[8] = {0};
    uint32_t can_id = 0x600 + node_id;
    
    // Set up write message to change operation mode
    data[0] = 0x2F;  // SDO write command (1 byte)
    data[1] = 0x60;  // Index LSB (0x6060 = Mode of operation)
    data[2] = 0x60;  // Index MSB
    data[3] = 0x00;  // Subindex
    data[4] = 0x01;  // Profile Position Mode
    
    CAN_TxHeaderTypeDef TxHeader;
    TxHeader.StdId = can_id;
    TxHeader.ExtId = 0;
    TxHeader.RTR = CAN_RTR_DATA;
    TxHeader.IDE = CAN_ID_STD;
    TxHeader.DLC = 8;
    TxHeader.TransmitGlobalTime = DISABLE;
    
    uint32_t tx_mailbox;
    HAL_StatusTypeDef status = HAL_CAN_AddTxMessage(hcan, &TxHeader, data, &tx_mailbox);
    
    if (status != HAL_OK) {
        return false;
    }
    
    HAL_Delay(10);
    
    // Send shutdown command
    EPOS4_SetControlWord(hcan, node_id, CMD_SHUTDOWN);
    HAL_Delay(10);
    
    // Send switch on command
    EPOS4_SetControlWord(hcan, node_id, CMD_SWITCH_ON);
    HAL_Delay(10);
    
    // Enable operation
    EPOS4_SetControlWord(hcan, node_id, CMD_ENABLE_OPERATION);
    HAL_Delay(10);
    
    return true;
}

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  
  // In case of error, turn on red LED (LD5) and keep it on
  HAL_GPIO_WritePin(LD5_GPIO_Port, LD5_Pin, GPIO_PIN_SET);
  
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

/**
 * @brief Send CANopen NMT command
 * @param hcan CAN handle
 * @param command NMT command (e.g., 0x01 = start, 0x02 = stop, 0x80 = pre-operational, 0x81 = reset node, 0x82 = reset communication)
 * @param node_id Target node ID or 0 for all nodes
 */
void CANopen_NMT_Command(CAN_HandleTypeDef* hcan, uint8_t command, uint8_t node_id)
{
    CAN_TxHeaderTypeDef TxHeader;
    uint32_t TxMailbox;
    uint8_t TxData[2];
    
    // NMT message is always ID 0x000
    TxHeader.StdId = 0x000;
    TxHeader.ExtId = 0;
    TxHeader.IDE = CAN_ID_STD;
    TxHeader.RTR = CAN_RTR_DATA;
    TxHeader.DLC = 2;
    TxHeader.TransmitGlobalTime = DISABLE;
    
    // First byte is the command
    TxData[0] = command;
    // Second byte is the node ID (0 means all nodes)
    TxData[1] = node_id;
    
    // Send the NMT command
    HAL_CAN_AddTxMessage(hcan, &TxHeader, TxData, &TxMailbox);
    
    // Short delay to ensure message is processed
    HAL_Delay(10);
}

/**
 * @brief Set EPOS4 mode of operation
 * @param hcan CAN handle
 * @param node_id EPOS4 node ID
 * @param mode Operation mode (e.g., MODE_PROFILE_POSITION)
 */
void EPOS4_SetOperationMode(CAN_HandleTypeDef* hcan, uint8_t node_id, uint8_t mode)
{
    // Send SDO command to set operation mode
    CAN_TxHeaderTypeDef TxHeader;
    uint32_t TxMailbox;
    uint8_t TxData[8] = {0};
    
    TxHeader.StdId = 0x600 + node_id; // SDO transmit ID
    TxHeader.ExtId = 0;
    TxHeader.IDE = CAN_ID_STD;
    TxHeader.RTR = CAN_RTR_DATA;
    TxHeader.DLC = 8;
    TxHeader.TransmitGlobalTime = DISABLE;
    
    // Command to write 1 byte to object 0x6060 (modes of operation) subindex 0
    TxData[0] = 0x2F;  // Write 1 byte (expedited)
    TxData[1] = 0x60;  // Index LSB
    TxData[2] = 0x60;  // Index MSB
    TxData[3] = 0x00;  // Subindex
    TxData[4] = mode;  // Mode value
    // Bytes 5-7 are padding (0)
    
    // Send message
    HAL_CAN_AddTxMessage(hcan, &TxHeader, TxData, &TxMailbox);
    
    // Wait for message to be processed
    HAL_Delay(10);
}

/**
 * @brief Set EPOS4 profile velocity
 * @param hcan CAN handle
 * @param node_id EPOS4 node ID
 * @param velocity Velocity value (encoder counts/sec)
 */
void EPOS4_SetProfileVelocity(CAN_HandleTypeDef* hcan, uint8_t node_id, uint32_t velocity)
{
    // Send SDO command to set profile velocity
    CAN_TxHeaderTypeDef TxHeader;
    uint32_t TxMailbox;
    uint8_t TxData[8] = {0};
    
    TxHeader.StdId = 0x600 + node_id; // SDO transmit ID
    TxHeader.ExtId = 0;
    TxHeader.IDE = CAN_ID_STD;
    TxHeader.RTR = CAN_RTR_DATA;
    TxHeader.DLC = 8;
    TxHeader.TransmitGlobalTime = DISABLE;
    
    // Command to write 4 bytes to object 0x6081 (profile velocity) subindex 0
    TxData[0] = 0x23;  // Write 4 bytes (expedited)
    TxData[1] = 0x81;  // Index LSB
    TxData[2] = 0x60;  // Index MSB
    TxData[3] = 0x00;  // Subindex
    
    // Velocity value in little-endian format
    TxData[4] = (uint8_t)(velocity & 0xFF);
    TxData[5] = (uint8_t)((velocity >> 8) & 0xFF);
    TxData[6] = (uint8_t)((velocity >> 16) & 0xFF);
    TxData[7] = (uint8_t)((velocity >> 24) & 0xFF);
    
    // Send message
    HAL_CAN_AddTxMessage(hcan, &TxHeader, TxData, &TxMailbox);
    
    // Wait for message to be processed
    HAL_Delay(10);
}

/**
 * @brief Set EPOS4 profile acceleration
 * @param hcan CAN handle
 * @param node_id EPOS4 node ID
 * @param acceleration Acceleration value (encoder counts/sec²)
 */
void EPOS4_SetProfileAcceleration(CAN_HandleTypeDef* hcan, uint8_t node_id, uint32_t acceleration)
{
    // Send SDO command to set profile acceleration
    CAN_TxHeaderTypeDef TxHeader;
    uint32_t TxMailbox;
    uint8_t TxData[8] = {0};
    
    TxHeader.StdId = 0x600 + node_id; // SDO transmit ID
    TxHeader.ExtId = 0;
    TxHeader.IDE = CAN_ID_STD;
    TxHeader.RTR = CAN_RTR_DATA;
    TxHeader.DLC = 8;
    TxHeader.TransmitGlobalTime = DISABLE;
    
    // Command to write 4 bytes to object 0x6083 (profile acceleration) subindex 0
    TxData[0] = 0x23;  // Write 4 bytes (expedited)
    TxData[1] = 0x83;  // Index LSB
    TxData[2] = 0x60;  // Index MSB
    TxData[3] = 0x00;  // Subindex
    
    // Acceleration value in little-endian format
    TxData[4] = (uint8_t)(acceleration & 0xFF);
    TxData[5] = (uint8_t)((acceleration >> 8) & 0xFF);
    TxData[6] = (uint8_t)((acceleration >> 16) & 0xFF);
    TxData[7] = (uint8_t)((acceleration >> 24) & 0xFF);
    
    // Send message
    HAL_CAN_AddTxMessage(hcan, &TxHeader, TxData, &TxMailbox);
    
    // Wait for message to be processed
    HAL_Delay(10);
}

/**
 * @brief Set EPOS4 profile deceleration
 * @param hcan CAN handle
 * @param node_id EPOS4 node ID
 * @param deceleration Deceleration value (encoder counts/sec²)
 */
void EPOS4_SetProfileDeceleration(CAN_HandleTypeDef* hcan, uint8_t node_id, uint32_t deceleration)
{
    // Send SDO command to set profile deceleration
    CAN_TxHeaderTypeDef TxHeader;
    uint32_t TxMailbox;
    uint8_t TxData[8] = {0};
    
    TxHeader.StdId = 0x600 + node_id; // SDO transmit ID
    TxHeader.ExtId = 0;
    TxHeader.IDE = CAN_ID_STD;
    TxHeader.RTR = CAN_RTR_DATA;
    TxHeader.DLC = 8;
    TxHeader.TransmitGlobalTime = DISABLE;
    
    // Command to write 4 bytes to object 0x6084 (profile deceleration) subindex 0
    TxData[0] = 0x23;  // Write 4 bytes (expedited)
    TxData[1] = 0x84;  // Index LSB
    TxData[2] = 0x60;  // Index MSB
    TxData[3] = 0x00;  // Subindex
    
    // Deceleration value in little-endian format
    TxData[4] = (uint8_t)(deceleration & 0xFF);
    TxData[5] = (uint8_t)((deceleration >> 8) & 0xFF);
    TxData[6] = (uint8_t)((deceleration >> 16) & 0xFF);
    TxData[7] = (uint8_t)((deceleration >> 24) & 0xFF);
    
    // Send message
    HAL_CAN_AddTxMessage(hcan, &TxHeader, TxData, &TxMailbox);
    
    // Wait for message to be processed
    HAL_Delay(10);
}

// Add ITM initialization function
void ITM_Init(void) {
    // Enable ITM port 0
    ITM->TCR |= ITM_TCR_ITMENA_Msk;
    ITM->TER |= (1UL << 0);
}

// Modify _write to use ITM
int _write(int file, char *ptr, int len) {
    for (int i = 0; i < len; i++) {
        ITM_SendChar((*ptr++));
    }
    return len;
}

// Add printf function
int printf(const char* format, ...) {
    va_list args;
    va_start(args, format);
    char buffer[128];
    vsnprintf(buffer, sizeof(buffer), format, args);
    va_end(args);
    for (char* p = buffer; *p != '\0'; p++) {
        ITM_SendChar(*p);
    }
}

// Parameter definitions
#define MAX_PARAMETERS 100
#define PARAM_NAME_MAX_LENGTH 16



// Parameter count helper macro
#define ARRAY_SIZE(x) (sizeof(x) / sizeof(x[0]))

// Save settings function placeholder
void save_settings(void) {
    // In a real implementation, this would save parameters to flash memory
    // For now, just log that settings would be saved
    printf("Settings would be saved to flash memory\r\n");
    
    // Example implementation would use HAL_FLASH functions:
    // 1. Unlock flash
    // 2. Erase sector
    // 3. Program parameters
    // 4. Lock flash
}

// Parameter get/set handler for UAVCAN
void handle_param_getset(CanardInstance* ins, CanardRxTransfer* transfer)
{
    // Feed the watchdog during parameter processing to prevent resets
    IWDG->KR = 0xAAAA;
    
    uint16_t index = 0xFFFF;
    uint8_t tag = 0;
    int offset = 0;
    int64_t val = 0;
    uint8_t buffer[UAVCAN_PROTOCOL_PARAM_VALUE_SIZE] = {0};
    param_t* p = NULL;

    // Clear buffer
    memset(buffer, 0, sizeof(buffer));
    
    // Decode the request
    canardDecodeScalar(transfer, offset, 13, false, &index);
    offset += 13;
    canardDecodeScalar(transfer, offset, 3, false, &tag);
    offset += 3;

    if (tag == 1) {
        canardDecodeScalar(transfer, offset, 64, false, &val);
        offset += 64;
    }

    // Check if request includes a parameter name (with safety checks)
    uint16_t n = 0;
    if (transfer->payload_len > (offset / 8)) {
        n = (transfer->payload_len - (offset / 8));
    }
    
    uint8_t name[PARAM_NAME_MAX_LENGTH + 1] = {0};
    if (n > 0) {
        uint8_t name_len = 0;
        if (canardDecodeScalar(transfer, offset, 8, false, &name_len)) {
            offset += 8;
            
            // Ensure name_len is within bounds to prevent buffer overflow
            if (name_len > 0 && name_len < PARAM_NAME_MAX_LENGTH) {
                for (int i = 0; i < name_len && i < PARAM_NAME_MAX_LENGTH && ((offset + 8) <= (transfer->payload_len * 8)); i++) {
                    canardDecodeScalar(transfer, offset, 8, false, &name[i]);
                    offset += 8;
                }
                name[name_len] = '\0'; // Ensure null termination
            }
        }
    }

    // Find the parameter
    if (strlen((char const*)name) > 0) {
        p = getParamByName((const char*)name);
        printf("Parameter request by name: %s\r\n", name);
    } else {
        p = getParamByIndex(index);
        printf("Parameter request by index: %d\r\n", index);
    }
    
    // If this is a set request and we found the parameter, update its value
    if ((p) && (tag == 1)) {
        // Update based on parameter type
        switch (p->type) {
            case PARAM_TYPE_INTEGER:
                p->value.i = (int32_t)val;
                p->val = (int32_t)val;
                break;
            case PARAM_TYPE_REAL:
                p->value.f = *((float*)&val); // Cast int64 bits to float
                p->val = (int32_t)val;
                break;
            case PARAM_TYPE_BOOLEAN:
                p->value.b = (val > 0);
                p->val = (val > 0) ? 1 : 0;
                break;
            case PARAM_TYPE_STRING: {
                // Keep this simple for now
                strncpy(p->value.str, "param", PARAM_NAME_MAX_LENGTH-1);
                break;
            }
            default:
                break;
        }
        printf("Setting parameter value to: %ld\r\n", (long)val);
        // save_settings(); - disabled to avoid potential flash issues
    }
    
    // For simplicity, just create a minimal response that won't cause issues
    offset = 0;
    
    if (p != NULL) {
        // Just encode the parameter value as an integer (simplest approach)
        buffer[offset++] = PARAM_TYPE_INTEGER;  // Integer type tag
        int64_t resp_val = p->val;
        memcpy(&buffer[offset], &resp_val, sizeof(int64_t));
        offset += sizeof(int64_t);
        
        // Default value
        memcpy(&buffer[offset], &resp_val, sizeof(int64_t));
        offset += sizeof(int64_t);
        
        // Min value
        int64_t min_val = -100000;
        memcpy(&buffer[offset], &min_val, sizeof(int64_t));
        offset += sizeof(int64_t);
        
        // Max value
        int64_t max_val = 100000;
        memcpy(&buffer[offset], &max_val, sizeof(int64_t));
        offset += sizeof(int64_t);
        
        // Parameter name
        uint8_t name_len = strlen(p->name);
        buffer[offset++] = name_len;
        memcpy(&buffer[offset], p->name, name_len);
        offset += name_len;
    } else {
        // Parameter not found - send empty response
        buffer[offset++] = PARAM_TYPE_EMPTY;
        buffer[offset++] = 0; // Empty name
    }
    
    // Ensure we don't exceed buffer size
    if (offset > UAVCAN_PROTOCOL_PARAM_VALUE_SIZE) {
        offset = UAVCAN_PROTOCOL_PARAM_VALUE_SIZE;
    }
    
    // Send response - simple direct approach
    static uint8_t param_transfer_id = 0;
    canardRequestOrRespond(ins,
                          transfer->source_node_id,
                          UAVCAN_PARAM_GETSET_SIGNATURE,
                          UAVCAN_PROTOCOL_PARAM_GETSET_ID,
                          &param_transfer_id,
                          CANARD_TRANSFER_PRIORITY_HIGH,
                          CanardResponse,
                          buffer,
                          offset);
    
    // Feed watchdog again
        IWDG->KR = 0xAAAA;
        
    printf("Parameter response sent\r\n");
}

void send_get_node_info_request(uint8_t target_node_id)
{
    static uint8_t dummy_payload[1] = {0};  // Empty payload
    static uint8_t transfer_id = 0;

    int result = canardRequestOrRespond(&canard,
                                        target_node_id,                        // Destination Node ID
                                        UAVCAN_PROTOCOL_GETNODEINFO_SIGNATURE, // Signature of GetNodeInfo
                                        UAVCAN_PROTOCOL_GETNODEINFO_ID,         // Data Type ID = 1
                                        &transfer_id,
                                        CANARD_TRANSFER_PRIORITY_LOW,           // or MEDIUM
                                        CanardRequest,                          // Transfer type REQUEST
                                        dummy_payload,
                                        0);  // Payload size 0 (empty)

    printf("Sent GetNodeInfo request to node %d, result: %d\r\n", target_node_id, result);
}

// Add this function to get microsecond timestamps
uint64_t micros64(void) {
    static uint32_t last_tick = 0;
    static uint64_t overflow_count = 0;
    
    uint32_t tick = HAL_GetTick();
    
    // Handle overflow
    if (tick < last_tick) {
        overflow_count += 1;
    }
    last_tick = tick;
    
    // Return microseconds (tick is in milliseconds, so multiply by 1000)
    return (overflow_count << 32) | (tick * 1000ULL);
}

/**
 * Translate EPOS4 position to normalized range [-1.0, 1.0]
 * @param position Raw EPOS4 position value
 * @return Normalized position value between -1.0 and 1.0
 */
float translateEPOS4Position(int32_t position)
{
    // Convert position to normalized range [-1.0, 1.0]
    float normalized = 0.0f;
    
    if (position < midPosition) {
        // Position is below center
        if (minPosition != midPosition) {
            normalized = (float)(position - midPosition) / (float)(midPosition - minPosition);
        }
    } else {
        // Position is above center
        if (maxPosition != midPosition) {
            normalized = (float)(position - midPosition) / (float)(maxPosition - midPosition);
        }
    }
    
    // Clamp to valid range
    if (normalized < -1.0f) normalized = -1.0f;
    if (normalized > 1.0f) normalized = 1.0f;
    
    return normalized;
}

/**
 * Get current EPOS4 normalized position between -1.0 and 1.0
 */
float getEPOS4NormalizedPosition(void)
{
    // For simplicity, we'll use the current_position global variable
    // This should be updated by the CAN callbacks from the EPOS4
    return translateEPOS4Position(current_position);
}

/**
 * Convert normalized position (-1.0 to 1.0) to EPOS4 encoder position
 * @param normalized_position Normalized position between -1.0 and 1.0
 * @return Raw EPOS4 encoder position
 */
int32_t getNormalizedToEPOS4Position(float normalized_position)
{
    // Clamp normalized position
    if (normalized_position < -1.0f) normalized_position = -1.0f;
    if (normalized_position > 1.0f) normalized_position = 1.0f;
    
    // Convert to encoder position
    int32_t position = 0;
    
    if (normalized_position < 0.0f) {
        // Position is below center
        position = midPosition + (int32_t)(normalized_position * (midPosition - minPosition));
    } else {
        // Position is above center
        position = midPosition + (int32_t)(normalized_position * (maxPosition - midPosition));
    }
    
    return position;
}

/**
 * Send actuator status message via UAVCAN
 * This provides feedback about the EPOS4 position
 */
void send_actuator_status(void)
{
    // Feed the watchdog to prevent reset during status send
    IWDG->KR = 0xAAAA;
    
    static uint8_t transfer_id = 0;
    
    // Prepare buffer for the message
    uint8_t buffer[UAVCAN_EQUIPMENT_ACTUATOR_STATUS_MAX_SIZE];
    memset(buffer, 0, UAVCAN_EQUIPMENT_ACTUATOR_STATUS_MAX_SIZE);
    
    // Get current timestamp and position
    uint64_t timestamp_usec = micros64();
    float normalized_position = getEPOS4NormalizedPosition();
    
    // Encode the timestamp (64 bits)
    canardEncodeScalar(buffer, 0, 64, &timestamp_usec);
    
    // Encode actuator ID (8 bits)
    uint8_t actuator_id = NODE_ID;  // Use node ID as the actuator ID for better identification
    canardEncodeScalar(buffer, 64, 8, &actuator_id);
    
    // Encode normalized position (-1.0 to 1.0, 32 bits float)
    canardEncodeScalar(buffer, 72, 32, &normalized_position);
    
    // Encode force (not used, set to 0)
    float force = 0.0f;
    canardEncodeScalar(buffer, 104, 32, &force);
    
    // Use current velocity (a fraction of max velocity based on position)
    float speed = 0.0f;
    canardEncodeScalar(buffer, 136, 32, &speed);
    
    // Encode power rating (not used, set to 0)
    float power_rating = 0.0f;
    canardEncodeScalar(buffer, 168, 32, &power_rating);
    
    // Minimal logging - just log that we're sending the status
    // Log what we're sending
    static uint32_t status_count = 0;
    if (status_count++ % 10 == 0) {
        // Only log every 10th status message to reduce flooding
        printf("Status: pos=%.2f\r\n", normalized_position);
    }
    
    // Directly construct a CAN message for a more direct approach - less likely to hang
    uint32_t message_id = (transfer_id++ & 0x1F) | 
                         (UAVCAN_EQUIPMENT_ACTUATOR_STATUS_DATA_TYPE_ID << 8) | 
                         ((CANARD_TRANSFER_PRIORITY_MEDIUM & 0x1F) << 24);
    
    CAN_TxHeaderTypeDef tx_header;
    uint32_t tx_mailbox;
    
    tx_header.StdId = 0;
    tx_header.ExtId = message_id;
    tx_header.IDE = CAN_ID_EXT;
    tx_header.RTR = CAN_RTR_DATA;
    tx_header.DLC = 8;  // First 8 bytes
    
    // Send directly with a few retries if needed
    HAL_StatusTypeDef status;
    for (int i = 0; i < 3; i++) {  // 3 attempts maximum
        status = HAL_CAN_AddTxMessage(&hcan1, &tx_header, buffer, &tx_mailbox);
        if (status == HAL_OK) {
            break;
        }
        HAL_Delay(1);  // Short delay between attempts
    }
    
    // IWDG refresh again after sending
    IWDG->KR = 0xAAAA;
}

void epos4_read_position(uint16_t index, uint8_t subindex)
{
    CAN_TxHeaderTypeDef tx_header;
    uint8_t tx_data[8];
    uint32_t tx_mailbox;

    // Setup CAN message header
    tx_header.StdId = 0x600 + EPOS4_NODE_ID;  // SDO client -> server
    tx_header.ExtId = 0;
    tx_header.IDE = CAN_ID_STD;
    tx_header.RTR = CAN_RTR_DATA;
    tx_header.DLC = 8;

    // Setup SDO read command
    tx_data[0] = 0x40;  // Read command
    tx_data[1] = index & 0xFF;
    tx_data[2] = (index >> 8) & 0xFF;
    tx_data[3] = subindex;
    tx_data[4] = 0;
    tx_data[5] = 0;
    tx_data[6] = 0;
    tx_data[7] = 0;

    // Send CAN message
    if (HAL_CAN_AddTxMessage(&hcan1, &tx_header, tx_data, &tx_mailbox) != HAL_OK)
    {
        Error_Handler();
    }
}

// Add these defines at the top of the file
#define UAVCAN_PROTOCOL_PARAM_GETSET_ID 11

// Parameter handling function declarations
static inline param_t * getParamByIndex(uint16_t index);
static inline param_t * getParamByName(const char * name);

// Parameter encoding for UAVCAN
uint16_t encodeParamCanard(param_t * p, uint8_t * buffer)
{
    uint8_t n     = 0;
    int offset    = 0;
    uint8_t tag   = 1;
    if(p==NULL)
    {   
        tag = 0;
        canardEncodeScalar(buffer, offset, 5, &n);
        offset += 5;
        canardEncodeScalar(buffer, offset,3, &tag);
        offset += 3;
        
        canardEncodeScalar(buffer, offset, 6, &n);
        offset += 6;
        canardEncodeScalar(buffer, offset,2, &tag);
        offset += 2;
        
        canardEncodeScalar(buffer, offset, 6, &n);
        offset += 6;
        canardEncodeScalar(buffer, offset, 2, &tag);
        offset += 2;
        buffer[offset / 8] = 0;
        return ( offset / 8 + 1 );
    }
    canardEncodeScalar(buffer, offset, 5,&n);
    offset += 5;
    canardEncodeScalar(buffer, offset, 3, &tag);
    offset += 3;
    canardEncodeScalar(buffer, offset, 64, &p->val);
    offset += 64;
    
    canardEncodeScalar(buffer, offset, 5, &n);
    offset += 5;
    canardEncodeScalar(buffer, offset, 3, &tag);
    offset += 3;
    canardEncodeScalar(buffer, offset, 64, &p->defval);
    offset += 64;
    
    canardEncodeScalar(buffer, offset, 6, &n);
    offset += 6;
    canardEncodeScalar(buffer, offset, 2, &tag);
    offset += 2;
    canardEncodeScalar(buffer, offset, 64, &p->max);
    offset += 64;
    
    canardEncodeScalar(buffer, offset, 6, &n);
    offset += 6;
    canardEncodeScalar(buffer, offset,2,&tag);
    offset += 2;
    canardEncodeScalar(buffer, offset,64,&p->min);
    offset += 64;
    
    memcpy(&buffer[offset / 8], p->name, strlen((char const*)p->name));
    return  (offset/8 + strlen((char const*)p->name)); 
}

void rawcmdHandleCanard(CanardRxTransfer* transfer)
{
    uint16_t rc_pwm[6] = {0};
    
    int offset = 0;
    for (int i = 0; i<6; i++)
    {
        if (canardDecodeScalar(transfer, offset, 14, true, &rc_pwm[i])<14) { break; }
        offset += 14;
    }
    
    // Log the RC values
    printf("RC values: %d %d %d %d %d %d\r\n", 
           rc_pwm[0], rc_pwm[1], rc_pwm[2], rc_pwm[3], rc_pwm[4], rc_pwm[5]);
    
    // Map RC values to motor control if needed
    if (rc_pwm[0] > 1500) {
        // Example: use first channel for position control
        int32_t position = (rc_pwm[0] - 1500) * 10; // Simple linear mapping
        epos4_set_target_position(position);
    }
}

// ... existing code ...

// ... existing code ...

// Parameter handling function declarations
static inline param_t * getParamByIndex(uint16_t index);
static inline param_t * getParamByName(const char * name);

// ... existing code ...

// Parameter handling function implementations
static inline param_t * getParamByIndex(uint16_t index)
{
    if(index >= ARRAY_SIZE(parameters)) 
    {
        return NULL;
    }

    return &parameters[index];
}

static inline param_t * getParamByName(const char * name)
{
    for(uint16_t i = 0; i < ARRAY_SIZE(parameters); i++)
    {
        if(strcmp(name, parameters[i].name) == 0)
        {
            return &parameters[i];
        }
    }      
    return NULL;
}

/**
 * Broadcast all parameters to speed up parameter detection
 */
void broadcast_all_parameters(void)
{
    printf("Broadcasting all parameters\r\n");
    
    // First, broadcast a heartbeat to ensure our node is visible
    uint8_t heartbeat_buffer[UAVCAN_NODE_STATUS_MESSAGE_SIZE];
    makeNodeStatusMessage(heartbeat_buffer);
    static uint8_t heartbeat_transfer_id = 0;
    
    // Send heartbeat with high priority
    canardBroadcast(&canard,
                   UAVCAN_NODE_STATUS_DATA_TYPE_SIGNATURE,
                   UAVCAN_NODE_STATUS_DATA_TYPE_ID,
                   &heartbeat_transfer_id,
                   CANARD_TRANSFER_PRIORITY_HIGH,
                   heartbeat_buffer,
                   UAVCAN_NODE_STATUS_MESSAGE_SIZE);
    
    // Process message to ensure it gets sent
    processTxRxOnce(&canard, 1);
    HAL_Delay(5);  // Very short delay 
    
    // Create a temporary parameter response buffer
    uint8_t buffer[UAVCAN_PROTOCOL_PARAM_VALUE_SIZE] = {0};
    static uint8_t param_transfer_id = 0;
    
    // Loop through all parameters and send them
    for (uint16_t i = 0; i < MAX_PARAMETERS; i++) {
        // Skip empty parameters
        if (parameters[i].name[0] == '\0') {
            continue;
        }
        
        printf("Broadcasting parameter %d: %s\r\n", i, parameters[i].name);
        
        // Create response buffer for this parameter
        int offset = 0;
        param_t* p = &parameters[i];
        
        // Encode based on type
        switch (p->type) {
            case PARAM_TYPE_INTEGER:
                buffer[offset++] = PARAM_TYPE_INTEGER;  // Integer type tag
                int64_t int_val = (int64_t)p->value.i;
                memcpy(&buffer[offset], &int_val, sizeof(int64_t));
                offset += sizeof(int64_t);
                int64_t default_val = (int64_t)p->defval;
                memcpy(&buffer[offset], &default_val, sizeof(int64_t));
                offset += sizeof(int64_t);
                int64_t min_val = (int64_t)p->min;
                memcpy(&buffer[offset], &min_val, sizeof(int64_t));
                offset += sizeof(int64_t);
                int64_t max_val = (int64_t)p->max;
                memcpy(&buffer[offset], &max_val, sizeof(int64_t));
                offset += sizeof(int64_t);
                break;
                
            case PARAM_TYPE_BOOLEAN:
                buffer[offset++] = PARAM_TYPE_BOOLEAN;  // Boolean type tag
                int64_t bool_val = p->value.b ? 1 : 0;
                memcpy(&buffer[offset], &bool_val, sizeof(int64_t));
                offset += sizeof(int64_t);
                int64_t bool_default = p->defval ? 1 : 0;
                memcpy(&buffer[offset], &bool_default, sizeof(int64_t));
                offset += sizeof(int64_t);
                int64_t bool_min = 0;
                memcpy(&buffer[offset], &bool_min, sizeof(int64_t));
                offset += sizeof(int64_t);
                int64_t bool_max = 1;
                memcpy(&buffer[offset], &bool_max, sizeof(int64_t));
                offset += sizeof(int64_t);
                break;
                
            case PARAM_TYPE_REAL:
                buffer[offset++] = PARAM_TYPE_REAL;  // Real type tag
                float real_val = p->value.f;
                memcpy(&buffer[offset], &real_val, sizeof(float));
                offset += sizeof(float);
                float def_val_f = (float)p->defval;
                memcpy(&buffer[offset], &def_val_f, sizeof(float));
                offset += sizeof(float);
                float min_val_f = (float)p->min;
                memcpy(&buffer[offset], &min_val_f, sizeof(float));
                offset += sizeof(float);
                float max_val_f = (float)p->max;
                memcpy(&buffer[offset], &max_val_f, sizeof(float));
                offset += sizeof(float);
                break;
                
            case PARAM_TYPE_STRING: {
                buffer[offset++] = PARAM_TYPE_STRING;
                
                // First string is empty (default value)
                buffer[offset++] = 0;
                
                // Second string is the actual value
                uint8_t str_len = strlen(p->value.str);
                buffer[offset++] = str_len;
                memcpy(&buffer[offset], p->value.str, str_len);
                offset += str_len;
                
                // Third string is empty (min value - not used for strings)
                buffer[offset++] = 0;
                
                // Fourth string is empty (max value - not used for strings)
                buffer[offset++] = 0;
                break;
            }
            
            default:
                buffer[offset++] = PARAM_TYPE_EMPTY;  // Empty type tag
                break;
        }
        
        // Add parameter name at the end
        uint8_t name_len = strlen(p->name);
        buffer[offset++] = name_len;
        memcpy(&buffer[offset], p->name, name_len);
        offset += name_len;
        
        // Add parameter index
        buffer[offset++] = i & 0xFF;
        buffer[offset++] = (i >> 8) & 0xFF;
        
        // Send this parameter THREE times for reliability, each with high priority
        for (int attempt = 0; attempt < 3; attempt++) {
            canardRequestOrRespond(&canard,
                                  CANARD_BROADCAST_NODE_ID,
                                  UAVCAN_PARAM_GETSET_SIGNATURE,
                                  UAVCAN_PROTOCOL_PARAM_GETSET_ID,
                                  &param_transfer_id,
                                  CANARD_TRANSFER_PRIORITY_HIGH,
                                  CanardResponse,
                                  buffer,
                                  offset);
            
            // Process TX queue right after each send (this is very important)
            for (int j = 0; j < 3; j++) {
                processTxRxOnce(&canard, 0);
            }
            
            HAL_Delay(2);  // Short delay between repeated sends
        }
        
        HAL_Delay(10);  // Delay between parameters
    }
    
    // Send a final heartbeat to ensure proper visibility
    canardBroadcast(&canard,
                   UAVCAN_NODE_STATUS_DATA_TYPE_SIGNATURE,
                   UAVCAN_NODE_STATUS_DATA_TYPE_ID,
                   &heartbeat_transfer_id,
                   CANARD_TRANSFER_PRIORITY_HIGH,
                   heartbeat_buffer,
                   UAVCAN_NODE_STATUS_MESSAGE_SIZE);
                   
    printf("Finished broadcasting parameters\r\n");
    
    // Process any pending messages
    for (int i = 0; i < 10; i++) {
        processTxRxOnce(&canard, 0);
        HAL_Delay(1);
    }
}

/**
 * Handle UAVCAN Equipment Actuator ArrayCommand
 * This receives commands from ArduPilot for servo/motor control
 */
void handleActuatorArrayCommand(CanardInstance* ins, CanardRxTransfer* transfer)
{
    // Feed the watchdog during command processing to prevent resets
    IWDG->KR = 0xAAAA;
    
    // Log basic command info
    printf("ActuatorArrayCommand received (%u bytes)\r\n", transfer->payload_len);
    
    // Set a timeout for the entire processing operation
    uint32_t start_time = HAL_GetTick();
    uint32_t timeout_ms = 1000; // 1 second maximum processing time
    
    // The ArrayCommand message starts with a 64-bit timestamp
    uint64_t timestamp = 0;
    
    // Start at bit offset 0
    int bit_offset = 0;
    
    // Try to decode the timestamp if there's enough data
    if (transfer->payload_len >= 8) {
        canardDecodeScalar(transfer, bit_offset, 64, false, &timestamp);
        bit_offset += 64;
    } else {
        // If message is too short for a timestamp, skip trying to decode it
        // ArduPilot sometimes sends abbreviated messages
        printf("Short array command (no timestamp): %u bytes\r\n", transfer->payload_len);
    }
    
    // Check if we have at least a node_id (1 byte) and command (2 bytes)
    if (transfer->payload_len >= 3) {
        // Even for short messages, try to extract the actuator ID and command
        uint8_t actuator_id = 0;
        
        // Check if there's enough bits left to decode the actuator ID
        if ((bit_offset + 8) <= (transfer->payload_len * 8)) {
            canardDecodeScalar(transfer, bit_offset, 8, false, &actuator_id);
            bit_offset += 8;
            
            // Check if there's enough bits left to decode the command value (16 bits)
            if ((bit_offset + 16) <= (transfer->payload_len * 8)) {
                int16_t command_raw = 0;
                canardDecodeScalar(transfer, bit_offset, 16, true, &command_raw);
                
                // Check if this command is for us (we match our NODE_ID or using ID 0)
                if ((actuator_id == NODE_ID || actuator_id == 0) && 
                    (HAL_GetTick() - start_time < timeout_ms)) {
                    printf("Cmd for actuator %d: %d -> ", actuator_id, command_raw);
                    
                    // Process the command by delegating to the command handler
                    handle_ardupilot_command(command_raw);
                    printf("position command processed\r\n");
                } else if (HAL_GetTick() - start_time >= timeout_ms) {
                    printf("Command processing timeout - skipping command\r\n");
                } else {
                    printf("Command for different actuator ID: %d (our ID: %d)\r\n", 
                          actuator_id, NODE_ID);
                }
            } else {
                printf("Command data missing from array command\r\n");
            }
        } else {
            printf("Actuator ID missing from array command\r\n");
        }
    } else {
        printf("Array command too short to contain command data: %u bytes\r\n", 
              transfer->payload_len);
    }
    
    // Feed watchdog one more time before exit
    IWDG->KR = 0xAAAA;
}

#define SERVO_PWM_MIN 1000
#define SERVO_PWM_CENTER 1500
#define SERVO_PWM_MAX 2000

/**
 * Initialize position parameters with sensible defaults for servo control
 */
void initializePositionParameters(void)
{
    // Set default position limits
    int32_t min_pos = -EPOS4_POSITION_LIMIT;
    int32_t max_pos = EPOS4_POSITION_LIMIT;
    int32_t center_pos = 0;
    
    // Update parameters
    param_t* min_pos_param = getParamByName("epos4.min_pos");
    if (min_pos_param != NULL) {
        min_pos_param->value.f = -1.0f;
    }
    
    param_t* max_pos_param = getParamByName("epos4.max_pos");
    if (max_pos_param != NULL) {
        max_pos_param->value.f = 1.0f;
    }
    
    param_t* center_pos_param = getParamByName("epos4.center");
    if (center_pos_param != NULL) {
        center_pos_param->value.f = 0.0f;
    }
    
    // Set operation mode to position mode
    epos4_set_operation_mode(1); // 1 = Profile Position Mode
    
    // Set velocity and acceleration limits
    param_t* vel_param = getParamByName("epos4.vel_max");
    if (vel_param != NULL) {
        epos4_send_sdo_write(EPOS4_TARGET_VELOCITY_INDEX, 0x00, vel_param->value.i, 4);
    }
    
    param_t* accel_param = getParamByName("epos4.accel");
    if (accel_param != NULL) {
        // Write acceleration and deceleration in sequence
        epos4_send_sdo_write(0x6083, 0x00, accel_param->value.i, 4); // Set acceleration
        HAL_Delay(5);
        epos4_send_sdo_write(0x6084, 0x00, accel_param->value.i, 4); // Set deceleration
    }
    
    // Enable the motor
    epos4_enable_motor();
    printf("Position parameters initialized: min=%.1f, center=%.1f, max=%.1f\r\n",
           min_pos_param->value.f, center_pos_param->value.f, max_pos_param->value.f);
}

// EPOS4 SDO write function
void epos4_send_sdo_write(uint16_t index, uint8_t subindex, uint32_t data, uint8_t data_length)
{
    CAN_TxHeaderTypeDef tx_header;
    uint8_t tx_data[8] = {0};
    uint32_t tx_mailbox;

    // Feed watchdog
    IWDG->KR = 0xAAAA;
    
    printf("Sending SDO write: idx=%04x:%02x, data=%08lx, len=%d\r\n", 
           index, subindex, (unsigned long)data, data_length);

    tx_header.StdId = 0x600 + EPOS4_NODE_ID;  // SDO client -> server
    tx_header.ExtId = 0;
    tx_header.IDE = CAN_ID_STD;
    tx_header.RTR = CAN_RTR_DATA;
    tx_header.DLC = 8;
    tx_header.TransmitGlobalTime = DISABLE;
    
    // Determine command byte based on data length
    uint8_t command;
    switch (data_length) {
        case 1:
            command = 0x2F;  // Write 1 byte
            break;
        case 2:
            command = 0x2B;  // Write 2 bytes
            break;
        case 4:
            command = 0x23;  // Write 4 bytes
            break;
        default:
            printf("Invalid data length: %d\r\n", data_length);
            return;
    }
    
    /* Format SDO message */
    tx_data[0] = command;
    tx_data[1] = (uint8_t)(index & 0xFF);        /* LSB of index */
    tx_data[2] = (uint8_t)((index >> 8) & 0xFF); /* MSB of index */
    tx_data[3] = subindex;
    
    /* For write commands, include data */
    tx_data[4] = (uint8_t)(data & 0xFF);
    tx_data[5] = (uint8_t)((data >> 8) & 0xFF);
    tx_data[6] = (uint8_t)((data >> 16) & 0xFF);
    tx_data[7] = (uint8_t)((data >> 24) & 0xFF);
    
    /* Send message */
    HAL_StatusTypeDef status = HAL_CAN_AddTxMessage(&hcan1, &tx_header, tx_data, &tx_mailbox);
    if (status != HAL_OK)
    {
        printf("ERROR: Failed to send SDO command\r\n");
        return;
    }
    
    /* Wait for message to be sent with timeout */
    uint32_t timeout = HAL_GetTick() + 100; /* 100ms timeout */
    while (HAL_CAN_GetTxMailboxesFreeLevel(&hcan1) != 3)
    {
        // Feed watchdog while waiting
        IWDG->KR = 0xAAAA;
        
        if (HAL_GetTick() > timeout)
        {
            printf("ERROR: TX timeout waiting for SDO send\r\n");
            return;
        }
    }
    
    printf("SDO write command sent successfully\r\n");
}

// Add this new function

/**
 * Force motor movement using direct SDO commands
 * This function bypasses the normal command path and directly writes to EPOS4 registers
 * @param position Target position in encoder counts
 */
void force_motor_movement(int32_t position)
{
    printf("Forcing motor to position: %ld using direct SDO commands\r\n", (long)position);
    
    // Refresh watchdog
    IWDG->KR = 0xAAAA;
    
    // STEP 1: Make sure operation is enabled
    CAN_TxHeaderTypeDef TxHeader1;
    uint8_t TxData1[8] = {0};
    uint32_t TxMailbox1;
    
    // Control word: Shutdown command
    TxHeader1.StdId = 0x600 + EPOS4_NODE_ID;
    TxHeader1.ExtId = 0;
    TxHeader1.RTR = CAN_RTR_DATA;
    TxHeader1.IDE = CAN_ID_STD;
    TxHeader1.DLC = 8;
    TxHeader1.TransmitGlobalTime = DISABLE;
    
    // Command to write control word (0x6040)
    TxData1[0] = 0x2B; // Write 2 bytes
    TxData1[1] = 0x40; // Index LSB (0x6040)
    TxData1[2] = 0x60; // Index MSB
    TxData1[3] = 0x00; // Subindex
    
    // Control word: 0x0006 (Shutdown)
    TxData1[4] = 0x06;
    TxData1[5] = 0x00;
    TxData1[6] = 0x00;
    TxData1[7] = 0x00;
    
    HAL_CAN_AddTxMessage(&hcan1, &TxHeader1, TxData1, &TxMailbox1);
    HAL_Delay(100); // Wait for processing
    
    // Refresh watchdog
    IWDG->KR = 0xAAAA;
    
    // STEP 2: Switch on
    TxData1[4] = 0x07; // Control word: 0x0007 (Switch on)
    HAL_CAN_AddTxMessage(&hcan1, &TxHeader1, TxData1, &TxMailbox1);
    HAL_Delay(100); // Wait for processing
    
    // Refresh watchdog
    IWDG->KR = 0xAAAA;
    
    // STEP 3: Enable operation
    TxData1[4] = 0x0F; // Control word: 0x000F (Enable operation)
    HAL_CAN_AddTxMessage(&hcan1, &TxHeader1, TxData1, &TxMailbox1);
    HAL_Delay(100); // Wait for processing
    
    // Refresh watchdog
    IWDG->KR = 0xAAAA;
    
    // STEP 4: Set target position
    CAN_TxHeaderTypeDef TxHeader2;
    uint8_t TxData2[8] = {0};
    uint32_t TxMailbox2;
    
    TxHeader2.StdId = 0x600 + EPOS4_NODE_ID;
    TxHeader2.ExtId = 0;
    TxHeader2.RTR = CAN_RTR_DATA;
    TxHeader2.IDE = CAN_ID_STD;
    TxHeader2.DLC = 8;
    TxHeader2.TransmitGlobalTime = DISABLE;
    
    // Command to write target position (0x607A)
    TxData2[0] = 0x23; // Write 4 bytes
    TxData2[1] = 0x7A; // Index LSB (0x607A)
    TxData2[2] = 0x60; // Index MSB
    TxData2[3] = 0x00; // Subindex
    
    // Position data (little endian)
    TxData2[4] = position & 0xFF;
    TxData2[5] = (position >> 8) & 0xFF;
    TxData2[6] = (position >> 16) & 0xFF;
    TxData2[7] = (position >> 24) & 0xFF;
    
    HAL_CAN_AddTxMessage(&hcan1, &TxHeader2, TxData2, &TxMailbox2);
    HAL_Delay(100); // Wait for processing
    
    // Refresh watchdog
    IWDG->KR = 0xAAAA;
    
    // STEP 5: Trigger motion with start bit
    // Control word with bit 4 set (start motion)
    TxData1[4] = 0x1F; // Control word: 0x001F (Enable + start motion)
    HAL_CAN_AddTxMessage(&hcan1, &TxHeader1, TxData1, &TxMailbox1);
    
    printf("Direct motion command sequence completed\r\n");
}

// In the main function after initialization, call our new function

// After existing code for initialization in main() function, add:

  // Initialize position parameters with defaults
  initializePositionParameters();
  
  // Broadcast parameters to improve detection speed
  printf("Broadcasting all parameters for quick discovery...\r\n");
  broadcast_all_parameters();
  
  // Try moving motor using both approaches
  printf("Moving motor to maximum position at startup...\r\n");
  HAL_Delay(500); // Give some time before starting movement
  
  // First try with normal function
  int32_t startup_position = 50000; // Use a large positive value
  printf("Sending absolute position command: %ld\r\n", (long)startup_position);
  epos4_set_target_position(startup_position);
  
  // Wait for motion to complete
  HAL_Delay(1000); // Wait a second for movement
  
  // Now try with direct function
  printf("Trying with direct force motor command\r\n");
  force_motor_movement(100000); // Even larger value
  
  // Wait for motion to complete
  HAL_Delay(2000); // Wait longer for this movement
  
  // Blink LED to indicate motions completed
  for (int i = 0; i < 3; i++) {
    HAL_GPIO_TogglePin(GPIOD, LD4_Pin); // Toggle green LED
    HAL_Delay(100);
  }
  
  printf("UAVCAN Node ready\r\n");
  /* USER CODE END 3 */



